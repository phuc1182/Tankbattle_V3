
====================
FILE: AudioManager.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\AudioManager.js
====================
class AudioManager {
    constructor() {
        this.sounds = {};        // {name: Audio instance}
        this.soundInstances = {}; // {name: [Audio instances]} - cho overlapping
        this.music = null;
        
        // === AUDIO OVERLAPPING CONFIG ===
        // Default d√πng pooling ƒë·ªÉ tr√°nh t·∫°o Audio li√™n t·ª•c (ngƒÉn leak)
        this.overlapMethod = 'pool'; // 'pool' | 'clone'
        
        // Cho pooling method: s·ªë instance pool m·ªói sound
        this.soundPoolSize = 5; // 5 instance cho m·ªói sound
        this.soundPools = {}; // {name: [pool of Audio instances]}
        
        // Tracking: √¢m thanh ƒëang ph√°t (ƒë·ªÉ cleanup)
        this.activeSounds = []; // Array c√°c Audio instance ƒëang ph√°t
    }

    loadSound(name, src) {
        // T·∫°o master Audio instance
        this.sounds[name] = new Audio(src);
        
        // === INIT SOUND POOLING ===
        // N·∫øu d√πng pool method, t·∫°o s·∫µn pool
        if (this.overlapMethod === 'pool') {
            this.soundPools[name] = [];
            for (let i = 0; i < this.soundPoolSize; i++) {
                const audio = new Audio(src);
                audio.preload = 'auto';
                this.soundPools[name].push(audio);
            }
        }
        
        // Init soundInstances array
        this.soundInstances[name] = [];
    }

    /**
     * Ph√°t √¢m thanh v·ªõi h·ªó tr·ª£ overlapping
     * @param {string} name - T√™n √¢m thanh
     * @param {boolean} loop - C√≥ l·∫∑p l·∫°i kh√¥ng
     * @param {boolean} allowOverlap - Cho ph√©p √¢m thanh ch·ªìng l√™n nhau (default: true cho shoot)
     */
    playSound(name, loop = false, allowOverlap = true) {
        if (!this.sounds[name]) return;

        // === PH∆Ø∆†NG PH√ÅP 1: CLONE NODE ===
        if (this.overlapMethod === 'clone' && allowOverlap) {
            try {
                // Clone audio node ƒë·ªÉ ph√°t song song
                const audioClone = this.sounds[name].cloneNode();
                audioClone.loop = loop;
                audioClone.volume = 1.0;
                
                // Ph√°t √¢m thanh
                const playPromise = audioClone.play();
                if (playPromise !== undefined) {
                    playPromise.catch(e => console.warn(`Audio play failed: ${name}`, e));
                }
                
                // Cleanup sau khi √¢m thanh k·∫øt th√∫c
                if (!loop) {
                    const onEnded = () => {
                        audioClone.pause();
                        audioClone.currentTime = 0;
                        this.activeSounds = this.activeSounds.filter(s => s !== audioClone);
                    };
                    audioClone.addEventListener('ended', onEnded, { once: true });
                }
                
                // Track active sound
                this.activeSounds.push(audioClone);
                
                return audioClone;
            } catch (e) {
                console.warn(`Clone audio failed: ${name}`, e);
                // Fallback: ph√°t √¢m thanh th∆∞·ªùng (c·∫Øt c≈©)
                this._playSoundDefault(name, loop);
            }
        }
        // === PH∆Ø∆†NG PH√ÅP 2: SOUND POOLING ===
        else if (this.overlapMethod === 'pool' && allowOverlap && this.soundPools[name]) {
            const pool = this.soundPools[name];
            
            // T√¨m audio instance ƒë√£ k·∫øt th√∫c
            let audioToUse = null;
            for (let audio of pool) {
                if (audio.paused || audio.ended) {
                    audioToUse = audio;
                    break;
                }
            }
            
            // N·∫øu t·∫•t c·∫£ ƒëang ph√°t, t·∫°o instance m·ªõi (fallback)
            if (!audioToUse) {
                audioToUse = new Audio(this.sounds[name].src);
                pool.push(audioToUse);
            }
            
            // Reset v√† ph√°t
            audioToUse.currentTime = 0;
            audioToUse.loop = loop;
            audioToUse.volume = 1.0;
            
            const playPromise = audioToUse.play();
            if (playPromise !== undefined) {
                playPromise.catch(e => console.warn(`Audio play failed: ${name}`, e));
            }
            
            return audioToUse;
        }
        // === DEFAULT: PH√ÅT TH∆Ø·ªúNG (C·∫ÆT C≈®) ===
        else {
            this._playSoundDefault(name, loop);
        }
    }

    /**
     * Ph√°t √¢m thanh m·∫∑c ƒë·ªãnh (c·∫Øt √¢m thanh c≈© n·∫øu ƒëang ph√°t)
     * @private
     */
    _playSoundDefault(name, loop) {
        if (this.sounds[name]) {
            const audio = this.sounds[name];
            audio.currentTime = 0;
            audio.loop = loop;
            
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.catch(e => {});
            }
            
            return audio;
        }
    }

    stopSound(name) {
        if (this.sounds[name]) {
            this.sounds[name].pause();
            this.sounds[name].currentTime = 0;
        }
        
        // Stop t·∫•t c·∫£ clones c·ªßa sound n√†y
        if (this.soundInstances[name]) {
            this.soundInstances[name].forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });
            this.soundInstances[name] = [];
        }
    }

    /**
     * D·ª´ng t·∫•t c·∫£ √¢m thanh ƒëang ph√°t
     */
    stopAllSounds() {
        // Stop master instances
        Object.values(this.sounds).forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
        });
        
        // Stop clone instances
        this.activeSounds.forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
        });
        this.activeSounds = [];
        
        // Stop pool instances
        Object.values(this.soundPools).forEach(pool => {
            pool.forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });
        });
    }

    playMusic(src) {
        if (this.music) {
            this.music.pause();
        }
        this.music = new Audio(src);
        this.music.loop = true;
        this.music.volume = 0.5; // Gi·∫£m √¢m l∆∞·ª£ng nh·∫°c n·ªÅn
        this.music.play().catch(e => {});
    }

    stopMusic() {
        if (this.music) {
            this.music.pause();
        }
    }

    /**
     * Thay ƒë·ªïi ph∆∞∆°ng ph√°p x·ª≠ l√Ω overlapping
     * @param {string} method - 'clone' ho·∫∑c 'pool'
     */
    setOverlapMethod(method) {
        if (method === 'clone' || method === 'pool') {
            this.overlapMethod = method;
            console.log(`Audio overlap method changed to: ${method}`);
        } else {
            console.warn(`Invalid overlap method: ${method}`);
        }
    }

    /**
     * L·∫•y th√¥ng tin v·ªÅ √¢m thanh ƒëang ph√°t
     */
    getAudioStats() {
        const activeSoundCount = this.activeSounds.filter(s => !s.paused && !s.ended).length;
        const totalPoolSize = Object.values(this.soundPools).reduce((sum, pool) => sum + pool.length, 0);
        
        return {
            method: this.overlapMethod,
            activeSoundCount,
            totalPoolSize,
            activeSoundInstances: this.activeSounds.length
        };
    }

    // Batch load sounds with progress
    loadSounds(sources, progressCb, doneCb) {
        const keys = Object.keys(sources);
        const total = keys.length;
        if (total === 0) {
            if (typeof doneCb === 'function') doneCb();
            return;
        }
        let loaded = 0;
        keys.forEach((key) => {
            const audio = new Audio(sources[key]);
            const onDone = () => {
                loaded++;
                this.sounds[key] = audio;
                
                // Init sound instances array
                this.soundInstances[key] = [];
                
                // Init pooling n·∫øu d√πng pool method
                if (this.overlapMethod === 'pool') {
                    this.soundPools[key] = [];
                    for (let i = 0; i < this.soundPoolSize; i++) {
                        const poolAudio = new Audio(sources[key]);
                        poolAudio.preload = 'auto';
                        this.soundPools[key].push(poolAudio);
                    }
                }
                
                if (typeof progressCb === 'function') progressCb(loaded, total);
                if (loaded === total && typeof doneCb === 'function') doneCb();
                audio.removeEventListener('canplaythrough', onDone);
                audio.removeEventListener('error', onDone);
            };
            audio.addEventListener('canplaythrough', onDone, { once: true });
            audio.addEventListener('error', onDone, { once: true });
            // Trigger load
            audio.load();
        });
    }
}

====================
FILE: Bullet.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Bullet.js
====================
class Bullet {
    // Client-side bullet wrapper cho prediction
    constructor(serverData) {
        this.id = serverData.id;
        // V·ªã tr√≠ hi·ªán t·∫°i (client t·ª± t√≠nh)
        this.x = serverData.x;
        this.y = serverData.y;
        // V·ªã tr√≠ t·ª´ server (ƒë·ªÉ sync)
        this.serverX = serverData.x;
        this.serverY = serverData.y;
        this.dx = serverData.dx;
        this.dy = serverData.dy;
        this.speed = serverData.speed || SharedConstants.BULLET_SPEED; // L·∫•y t·ª´ SharedConstants
        this.type = serverData.type;
        this.lastUpdateTime = Date.now();
        this.synced = false; // ƒê√°nh d·∫•u ƒë√£ nh·∫≠n sync ƒë·∫ßu ti√™n ch∆∞a
    }

    // Update t·ª´ server data
    updateFromServer(serverData) {
        this.serverX = serverData.x;
        this.serverY = serverData.y;
        this.dx = serverData.dx;
        this.dy = serverData.dy;
        this.type = serverData.type;

        // V·ªõi ƒë·∫°n: ch·ªâ snap khi t·∫°o l·∫ßn ƒë·∫ßu ho·∫∑c l·ªách l·ªõn, tr√°nh lerp l√†m ch·∫≠m ƒë·∫°n
        const dist = SharedUtils.distance(this.x, this.y, this.serverX, this.serverY);
        if (!this.synced || dist > 60) {
            // Snap c·ª©ng n·∫øu l·ªách l·ªõn ho·∫∑c l·∫ßn ƒë·∫ßu
            this.x = this.serverX;
            this.y = this.serverY;
            this.synced = true;
        } else if (dist > 5) {
            // Lerp m·∫°nh n·∫øu l·ªách v·ª´a
            const correctionFactor = 0.85;
            this.x += (this.serverX - this.x) * correctionFactor;
            this.y += (this.serverY - this.y) * correctionFactor;
        }
        // N·∫øu l·ªách nh·ªè (<5px) gi·ªØ nguy√™n ƒë·ªÉ tr√°nh jitter
        this.lastUpdateTime = Date.now();
    }

    // Client-side prediction: t·ª± t√≠nh v·ªã tr√≠ m·ªói frame
    update() {
        this.x += this.dx * this.speed;
        this.y += this.dy * this.speed;
    }

    draw(ctx) {
        const image = IMAGES.bullet;
        if (image) {
            ctx.drawImage(image, this.x - 8, this.y - 8, 16, 16);
        } else {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
            if (this.type === 1) ctx.fillStyle = "orange";
            else if (this.type === 2) ctx.fillStyle = "red";
            else if (this.type === 3) ctx.fillStyle = "yellow";
            ctx.fill();
            ctx.closePath();
        }
    }

    // Static method ƒë·ªÉ v·∫Ω raw data t·ª´ server (backward compatibility)
    static drawRaw(ctx, bulletData) {
        const image = IMAGES.bullet;
        if (image) {
            ctx.drawImage(image, bulletData.x - 8, bulletData.y - 8, 16, 16);
        } else {
            ctx.beginPath();
            ctx.arc(bulletData.x, bulletData.y, 5, 0, Math.PI * 2);
            if (bulletData.type === 1) ctx.fillStyle = "orange";
            else if (bulletData.type === 2) ctx.fillStyle = "red";
            else if (bulletData.type === 3) ctx.fillStyle = "yellow";
            ctx.fill();
            ctx.closePath();
        }
    }
}

====================
FILE: Config.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Config.js
====================
// Config.js - C·∫•u h√¨nh game
// T·∫•t c·∫£ c√°c h·∫±ng s·ªë game gi·ªù ƒë∆∞·ª£c qu·∫£n l√Ω trong SharedConstants.js
// File n√†y ch·ªâ gi·ªØ l·∫°i c·∫•u h√¨nh controls ng∆∞·ªùi ch∆°i

let controlsP1 = { up: 'w', down: 's', left: 'a', right: 'd', shoot: ' ' };

// Global
window.controlsP1 = controlsP1;

====================
FILE: Game.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Game.js
====================
// Game.js - Logic game ch√≠nh (multiplayer)
let gameMap, tank1, tank2;
let bullets = []; // M·∫£ng Bullet objects v·ªõi client-side prediction
let bulletMap = new Map(); // Map id -> Bullet instance
window.bulletMap = bulletMap; // Expose globally cho Tank.js
let items = [];
let turrets = []; // Turrets t·ª´ server
let particleSystem;
let isGameOver = false;
let isRenderLoopRunning = false;

// DOM elements
const gameOverLayer = document.getElementById('game-over-layer');
const winnerText = document.getElementById('winner-text');
const homeBtn = document.getElementById('homeBtn');

function initGame() {
    // Reset state m·ªói l·∫ßn nh·∫≠n gameState (v√≠ d·ª• restart)
    bullets = [];
    bulletMap = new Map();
    window.bulletMap = bulletMap;
    items = [];
    turrets = [];
    isGameOver = false;

    // T·∫°o Map t·ª´ server
    gameMap = new GameMap(window.gameState.map.width, window.gameState.map.height, SharedConstants.TILE_SIZE);
    gameMap.walls = window.gameState.map.walls;
    // X√¢y chunk index cho t∆∞·ªùng ƒë·ªÉ collision client kh√¥ng duy·ªát to√†n b·ªô
    if (gameMap.walls && gameMap.walls.length > 0) {
        gameMap.buildWallChunks();
    }

    // T√¨m player c·ªßa socket hi·ªán t·∫°i trong gameState
    const myPlayerId = Object.keys(window.gameState.players).find(socketId => socketId === window.socket.id);
    const myPlayerData = myPlayerId ? window.gameState.players[myPlayerId] : null;
    const isP1 = myPlayerData && myPlayerData.id === 'p1';
    
    // T·∫°o tanks instances v·ªõi m√†u d·ª±a tr√™n socketId
    // Socket c·ªßa m√¨nh lu√¥n d√πng tank1 (m√†u xanh), socket kia d√πng tank2 (m√†u ƒë·ªè)
    tank1 = new Tank(0, 0, "tank1", isP1 ? "p1" : "p2");
    tank2 = new Tank(0, 0, "tank2", isP1 ? "p2" : "p1");

    // Reset input state khi (re)join
    tank1.resetInput();
    tank2.resetInput();

    // Setup controls cho tank1 (tank c·ªßa m√¨nh)
    tank1.setupControls();

    // T·∫°o h·ªá th·ªëng h·∫°t
    particleSystem = new ParticleSystem();
    window.particleSystem = particleSystem;

    // Items t·ª´ server
    items = window.gameState.items;

    // Ph√°t nh·∫°c n·ªÅn
    if (window.audioManager) {
        window.audioManager.playMusic('sounds/bgmusic.mp3');
    }

    // Start rendering (ch·ªâ kh·ªüi ƒë·ªông m·ªôt l·∫ßn)
    if (!isRenderLoopRunning) {
        isRenderLoopRunning = true;
        window.renderGame();
    }
}

// H√†m render game (thay cho gameLoop)
function renderGame() {
    if (!window.gameState) return;

    // Update local state
    const oldItems = items || [];
    items = window.gameState.items; // S·ª≠ d·ª•ng raw data t·ª´ server
    turrets = window.gameState.turrets || []; // L·∫•y turrets t·ª´ server

    // Client-side bullet prediction: Sync v·ªõi server v√† t·ª± update
    const oldBulletIds = new Set(bulletMap.keys());
    const serverBullets = window.gameState.bullets;
    const currentBulletIds = new Set();

    // Update ho·∫∑c t·∫°o bullets t·ª´ server
    serverBullets.forEach(serverBullet => {
        currentBulletIds.add(serverBullet.id);
        if (bulletMap.has(serverBullet.id)) {
            // ƒê√£ c√≥ - update t·ª´ server
            bulletMap.get(serverBullet.id).updateFromServer(serverBullet);
        } else {
            // M·ªõi - t·∫°o Bullet instance
            bulletMap.set(serverBullet.id, new Bullet(serverBullet));
        }
    });

    // X√≥a bullets kh√¥ng c√≤n tr√™n server
    const removedBulletIds = [];
    oldBulletIds.forEach(id => {
        if (!currentBulletIds.has(id)) {
            const bullet = bulletMap.get(id);
            if (bullet) removedBulletIds.push(bullet);
            bulletMap.delete(id);
        }
    });

    // Client-side prediction: T·ª± update v·ªã tr√≠ bullets m·ªói frame
    bulletMap.forEach(bullet => bullet.update());
    bullets = Array.from(bulletMap.values());

    const players = Object.values(window.gameState.players);
    
    // T√¨m data c·ªßa m√¨nh v√† ƒë·ªëi ph∆∞∆°ng
    const mySocketId = window.socket.id;
    const myPlayerData = window.gameState.players[mySocketId];
    const enemyPlayerData = players.find(p => Object.keys(window.gameState.players).find(sid => window.gameState.players[sid] === p) !== mySocketId);
    
    // Tank1 l√† m√¨nh, Tank2 l√† ƒë·ªãch
    if (myPlayerData) {
        tank1.updateFromData(myPlayerData);
        tank1.update(); // Lerp v·ªã tr√≠ ƒë·ªÉ chuy·ªÉn ƒë·ªông m∆∞·ª£t m√†
        // T·∫°o b·ª•i khi xe di chuy·ªÉn (ph√≠a sau xe)
        if (particleSystem && (myPlayerData.keys?.up || myPlayerData.keys?.down || myPlayerData.keys?.left || myPlayerData.keys?.right)) {
            if (Math.random() < 0.3) { // 30% chance m·ªói frame
                // T√≠nh v·ªã tr√≠ b·ª•i ph√≠a sau xe (ng∆∞·ª£c h∆∞·ªõng ƒëi)
                const dustX = myPlayerData.x + myPlayerData.width/2 - myPlayerData.lastDx * 20;
                const dustY = myPlayerData.y + myPlayerData.height/2 - myPlayerData.lastDy * 20;
                particleSystem.createDust(dustX, dustY, 1);
            }
        }
    }
    if (enemyPlayerData) {
        tank2.updateFromData(enemyPlayerData);
        tank2.updateSimple(); // D√πng lerp ƒë∆°n gi·∫£n, kh√¥ng prediction
        // T·∫°o b·ª•i khi xe di chuy·ªÉn (ph√≠a sau xe)
        if (particleSystem && (enemyPlayerData.keys?.up || enemyPlayerData.keys?.down || enemyPlayerData.keys?.left || enemyPlayerData.keys?.right)) {
            if (Math.random() < 0.3) {
                const dustX = enemyPlayerData.x + enemyPlayerData.width/2 - enemyPlayerData.lastDx * 20;
                const dustY = enemyPlayerData.y + enemyPlayerData.height/2 - enemyPlayerData.lastDy * 20;
                particleSystem.createDust(dustX, dustY, 1);
            }
        }
    }

    // Kh√¥ng ph√°t √¢m thanh khi ƒë·∫°n ƒëang bay, ch·ªâ ph√°t khi nh·∫•n b·∫Øn (x·ª≠ l√Ω ·ªü Tank.setupControls)

    // Ph√°t hi·ªán ƒë·∫°n b·ªã x√≥a (va ch·∫°m t∆∞·ªùng/ng∆∞·ªùi) ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng n·ªï
    if (particleSystem && removedBulletIds.length > 0) {
        removedBulletIds.forEach(bullet => {
            const inMap = bullet.x >= 0 && bullet.x <= window.gameState.map.width && 
                          bullet.y >= 0 && bullet.y <= window.gameState.map.height;
            if (inMap) {
                const color = bullet.type === 2 ? 'red' : bullet.type === 3 ? 'yellow' : 'orange';
                particleSystem.createExplosion(bullet.x, bullet.y, 8, color, 25, 3);
            }
        });
    }

    isGameOver = window.gameState.isGameOver;

    if (isGameOver && window.gameState.winner) {
        endGame(window.gameState.winner);
        return; // D·ª´ng render loop
    }

    // targetTank lu√¥n l√† tank1 (m√¨nh)
    const targetTank = tank1;

    // Ph√°t hi·ªán item b·ªã nh·∫∑t g·∫ßn m√¨nh (tr√°nh trigger khi item ra kh·ªèi viewport)
    if (oldItems.length > 0 && items.length <= oldItems.length) {
        let pickedNearMe = false;
        const tol = 2;
        const radius = 80;
        if (targetTank) {
            oldItems.forEach(oi => {
                const stillExists = items.some(ni => ni.type === oi.type && Math.abs(ni.x - oi.x) < tol && Math.abs(ni.y - oi.y) < tol);
                if (!stillExists) {
                    const dx = (oi.x + 15) - (targetTank.x + targetTank.width / 2);
                    const dy = (oi.y + 15) - (targetTank.y + targetTank.height / 2);
                    if (Math.hypot(dx, dy) < radius) {
                        pickedNearMe = true;
                    }
                }
            });
        }
        if (pickedNearMe && window.audioManager) window.audioManager.playSound('pickup');
    }

    // Update particle system
    if (particleSystem) {
        particleSystem.update();
    }

    // Render main screen
    window.renderPlayerScreen(window.ctx, window.canvas, targetTank, gameMap, bullets, tank1, tank2, items, particleSystem, myPlayerData, turrets);
    
    // Render mini-map
    const minimapCanvas = document.getElementById('minimap');
    if (minimapCanvas && targetTank) {
        window.renderMiniMap(minimapCanvas, gameMap, targetTank, players, turrets, items);
    }

    requestAnimationFrame(renderGame);
}

// H√†m g·ªçi khi c√≥ ng∆∞·ªùi h·∫øt m√°u
function endGame(winnerId) {
    // Ch·ªâ hi·ªÉn th·ªã game over 1 l·∫ßn
    if (gameOverLayer.style.display === 'flex') return;
    
    isGameOver = true;
    // Cho ph√©p render loop kh·ªüi ƒë·ªông l·∫°i khi restart
    isRenderLoopRunning = false;
    
    // D·ª´ng nh·∫°c n·ªÅn
    if (window.audioManager) window.audioManager.stopMusic();
    
    // Hi·ªán b·∫£ng th√¥ng b√°o
    gameOverLayer.style.display = 'flex';
    winnerText.innerText = winnerId.toUpperCase() + " CHI·∫æN TH·∫ÆNG!";
    
    // ƒê·ªïi m√†u ch·ªØ
    if (winnerId === "p1") {
        winnerText.style.color = "#3498db";
    } else {
        winnerText.style.color = "#e74c3c";
    }
    
    // T·ª± ƒë·ªông r·ªùi ph√≤ng v√† reload sau 3 gi√¢y
    setTimeout(() => {
        if (window.socket && window.roomId) {
            window.socket.emit('leaveRoom', { roomId: window.roomId });
        }
        location.reload();
    }, 3000);
    
    console.log('Game Over! Winner:', winnerId);
}

// Global
window.initGame = initGame;
window.renderGame = renderGame;
window.endGame = endGame;
window.gameMap = gameMap;
window.tank1 = tank1;
window.tank2 = tank2;
window.bullets = bullets;
window.items = items;
window.particleSystem = particleSystem;
window.isGameOver = isGameOver;

====================
FILE: ImageLoader.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\ImageLoader.js
====================
// ImageLoader.js - Qu·∫£n l√Ω h√¨nh ·∫£nh
const IMAGES = {}; // Bi·∫øn ch·ª©a t·∫•t c·∫£ ·∫£nh ƒë√£ load

function loadImages(doneCb, progressCb) {
    const sources = {
        tank1: 'images/tank1.png',
        tank2: 'images/tank2.png',
        wall:  'images/wall.png',
        bg:    'images/bg.png',
        bullet:'images/bullet.png'
    };

    const keys = Object.keys(sources);
    const total = keys.length;
    let loaded = 0;

    keys.forEach((key) => {
        IMAGES[key] = new Image();
        IMAGES[key].src = sources[key];
        IMAGES[key].onload = () => {
            loaded++;
            if (typeof progressCb === 'function') {
                progressCb(loaded, total);
            }
            if (loaded === total && typeof doneCb === 'function') {
                doneCb();
            }
        };
        IMAGES[key].onerror = () => {
            // V·∫´n tƒÉng ƒë·ªÉ kh√¥ng k·∫πt loading n·∫øu ·∫£nh l·ªói
            loaded++;
            if (typeof progressCb === 'function') {
                progressCb(loaded, total);
            }
            if (loaded === total && typeof doneCb === 'function') {
                doneCb();
            }
        };
    });
}

// Global
window.IMAGES = IMAGES;
window.loadImages = loadImages;

====================
FILE: Items.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Items.js
====================
class Item {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 1: Health, 2: Speed, 3: Shield, 4: Fire Ammo, 5: Cluster Ammo, 6: Stealth
        this.width = 30;
        this.height = 30;
    }

    // Static method ƒë·ªÉ v·∫Ω item t·ª´ raw data (t·ªëi ∆∞u b·ªô nh·ªõ)
    static drawRaw(ctx, item) {
        const width = 30;
        const height = 30;
        ctx.save();
        
        if (item.type === 1) {
            // Heal
            ctx.fillStyle = "#00ff00";
            ctx.fillRect(item.x, item.y, width, height);
            ctx.fillStyle = "white"; ctx.font = "bold 20px Arial";
            ctx.fillText("H", item.x + 8, item.y + 22);
        } else if (item.type === 2) {
            // Speed
            ctx.fillStyle = "yellow";
            ctx.fillRect(item.x, item.y, width, height);
            ctx.fillStyle = "black"; ctx.font = "bold 20px Arial";
            ctx.fillText("S", item.x + 8, item.y + 22);
        } else if (item.type === 3) {
            // Shield
            ctx.fillStyle = "#808080";
            ctx.fillRect(item.x, item.y, width, height);
            ctx.fillStyle = "white"; ctx.font = "bold 20px Arial";
            ctx.fillText("G", item.x + 8, item.y + 22);
        } else if (item.type === 4) {
            // Fire Ammo (Cam ƒë·ªè - üî•)
            ctx.fillStyle = "#ff4500";
            ctx.fillRect(item.x, item.y, width, height);
            ctx.fillStyle = "white"; ctx.font = "bold 20px Arial";
            ctx.fillText("üî•", item.x + 5, item.y + 22);
        } else if (item.type === 5) {
            // Cluster Ammo (T√≠m - üí•)
            ctx.fillStyle = "#9400d3";
            ctx.fillRect(item.x, item.y, width, height);
            ctx.fillStyle = "white"; ctx.font = "bold 20px Arial";
            ctx.fillText("üí•", item.x + 5, item.y + 22);
        } else if (item.type === 6) {
            // Stealth (ƒêen - üëª)
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(item.x, item.y, width, height);
            ctx.fillStyle = "white"; ctx.font = "bold 20px Arial";
            ctx.fillText("üëª", item.x + 5, item.y + 22);
        }
        
        // V·∫Ω vi·ªÅn s√°ng
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.strokeRect(item.x, item.y, width, height);
        
        ctx.restore();
    }

    draw(ctx) {
        // S·ª≠ d·ª•ng drawRaw ƒë·ªÉ gi·ªØ nh·∫•t qu√°n  
        Item.drawRaw(ctx, this);
    }
}

====================
FILE: main.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\main.js
====================
// main.js - File ch√≠nh kh·ªüi ƒë·ªông game

// L·∫•y Context
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Socket connection
const socket = io(window.location.origin, {
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000
});
window.socket = socket; // Make socket global for Tank.js

// Set canvas for Game
window.canvas = canvas;
window.ctx = ctx;

// UI elements
const lobbyLayer = document.getElementById('lobby-layer');
const waitingLayer = document.getElementById('waiting-layer');
const loadingLayer = document.getElementById('loading-layer');
const loadingProgressBar = document.getElementById('loading-progress');
const loadingText = document.getElementById('loading-text');
const createRoomBtn = document.getElementById('createRoomBtn');
const joinRoomBtn = document.getElementById('joinRoomBtn');
const roomIdInput = document.getElementById('roomIdInput');
const startGameBtn = document.getElementById('startGameBtn');
const leaveRoomBtn = document.getElementById('leaveRoomBtn');
const roomIdText = document.getElementById('room-id-text');
const playerCountText = document.getElementById('player-count-text');
const copyRoomIdBtn = document.getElementById('copyRoomIdBtn');

window.isHost = false;

// Create room
createRoomBtn.addEventListener('click', () => {
    const roomId = Math.random().toString(36).substr(2, 8).toUpperCase();
    socket.emit('createRoom', { roomId });
    window.roomId = roomId;
    window.isHost = true;
});

// Join room
joinRoomBtn.addEventListener('click', () => {
    const roomId = roomIdInput.value.trim();
    if (!roomId) {
        alert('Vui l√≤ng nh·∫≠p Room ID!');
        return;
    }
    console.log('Attempting to join room:', roomId);
    socket.emit('joinRoom', { roomId });
    window.roomId = roomId;
    window.isHost = false;
});

// Start game (ch·ªâ host m·ªõi c√≥ n√∫t n√†y)
startGameBtn.addEventListener('click', () => {
    socket.emit('startGame', { roomId: window.roomId });
});

// Copy Room ID
copyRoomIdBtn.addEventListener('click', () => {
    const roomId = window.roomId;
    console.log('Copying Room ID:', roomId, 'Length:', roomId?.length);
    if (!roomId) {
        alert('Ch∆∞a c√≥ Room ID!');
        return;
    }
    navigator.clipboard.writeText(roomId).then(() => {
        const originalText = copyRoomIdBtn.textContent;
        copyRoomIdBtn.textContent = '‚úì ƒê√É COPY!';
        copyRoomIdBtn.style.backgroundColor = '#27ae60';
        console.log('Successfully copied:', roomId);
        setTimeout(() => {
            copyRoomIdBtn.textContent = originalText;
            copyRoomIdBtn.style.backgroundColor = '#3498db';
        }, 2000);
    }).catch(err => {
        alert('Kh√¥ng th·ªÉ copy. Vui l√≤ng copy th·ªß c√¥ng: ' + roomId);
        console.error('Copy failed:', err);
    });
});

// Leave room
leaveRoomBtn.addEventListener('click', () => {
    socket.emit('leaveRoom', { roomId: window.roomId });
    waitingLayer.style.display = 'none';
    lobbyLayer.style.display = 'flex';
    window.roomId = null;
    roomIdInput.value = '';
});

socket.on('connect', () => {
    console.log('Connected to server');
});

socket.on('disconnect', () => {
    console.log('Disconnected from server');
});

socket.on('connect_error', (error) => {
    console.error('Connection error:', error);
    // Ch·ªâ c·∫£nh b√°o n·∫øu kh√¥ng t·ª± ƒë·ªông reconnect ƒë∆∞·ª£c
    // Socket.IO s·∫Ω t·ª± th·ª≠ reconnect theo c·∫•u h√¨nh
});

socket.io.on('reconnect_attempt', (attempt) => {
    console.log('Reconnecting...', attempt);
});

socket.io.on('reconnect', (attempt) => {
    console.log('Reconnected after', attempt, 'attempt(s)');
});

socket.io.on('reconnect_failed', () => {
    console.error('Reconnection failed');
    alert('M·∫•t k·∫øt n·ªëi v·ªõi server. Vui l√≤ng t·∫£i l·∫°i trang.');
});

socket.on('roomCreated', (data) => {
    console.log('Room created event received:', data);
    console.log('Room ID:', data.roomId, 'Length:', data.roomId.length);
    lobbyLayer.style.display = 'none';
    waitingLayer.style.display = 'flex';
    roomIdText.textContent = data.roomId;
    window.roomId = data.roomId; // ƒê·∫£m b·∫£o window.roomId ƒë∆∞·ª£c set
    playerCountText.textContent = '1/2';
    window.playerId = data.playerId;
    window.isP1 = data.isP1;
    window.isHost = true;
    // Host c√≥ n√∫t Start (hi·ªÉn khi ƒë·ªß 2 ng∆∞·ªùi)
    startGameBtn.style.display = 'none';
    console.log('Room ID displayed:', roomIdText.textContent, 'window.roomId:', window.roomId);
});
socket.on('joinedRoom', (data) => {
    console.log('Successfully joined room!', data);
    lobbyLayer.style.display = 'none';
    waitingLayer.style.display = 'flex';
    roomIdText.textContent = window.roomId;
    playerCountText.textContent = data.playerCount + '/2';
    window.playerId = data.playerId;
    window.isP1 = data.isP1;
    window.isHost = false;
    if (data.playerCount === 2) {
        document.querySelector('.waiting-msg').textContent = 'ƒê·ªß ng∆∞·ªùi ch∆°i! ƒêang ch·ªù host b·∫Øt ƒë·∫ßu...';
    }
});
socket.on('playerJoined', (data) => {
    playerCountText.textContent = data.playerCount + '/2';
    if (data.playerCount === 2 && window.isHost) {
        // Hi·ªÉn n√∫t Start cho host
        startGameBtn.style.display = 'block';
        document.querySelector('.waiting-msg').textContent = 'ƒê·ªß ng∆∞·ªùi ch∆°i! Nh·∫•n Start ƒë·ªÉ b·∫Øt ƒë·∫ßu.';
    } else if (data.playerCount === 2) {
        document.querySelector('.waiting-msg').textContent = 'ƒê·ªß ng∆∞·ªùi ch∆°i! ƒêang ch·ªù host b·∫Øt ƒë·∫ßu...';
    }
});

socket.on('roomFull', () => {
    alert('Ph√≤ng ƒë√£ ƒë·∫ßy! M·ªói ph√≤ng ch·ªâ ch·ª©a t·ªëi ƒëa 2 ng∆∞·ªùi ch∆°i.');
    window.roomId = null;
    roomIdInput.value = '';
});

socket.on('roomNotFound', () => {
    console.log('Room not found!');
    alert('Kh√¥ng t√¨m th·∫•y ph√≤ng! Vui l√≤ng ki·ªÉm tra l·∫°i Room ID.');
    waitingLayer.style.display = 'none';
    lobbyLayer.style.display = 'flex';
    window.roomId = null;
    roomIdInput.value = '';
});

socket.on('hostChanged', (data) => {
    const { hostId } = data;
    window.isHost = hostId === window.playerId;
    // N·∫øu ƒëang ·ªü ph√≤ng ch·ªù v√† ƒë·ªß 2 ng∆∞·ªùi, hi·ªÉn th·ªã n√∫t Start cho host m·ªõi
    const countText = playerCountText.textContent || '0/2';
    const count = parseInt(countText.split('/')[0], 10) || 0;
    if (waitingLayer.style.display !== 'none' && count === 2) {
        startGameBtn.style.display = window.isHost ? 'block' : 'none';
    }
});

// Khi host r·ªùi ph√≤ng, kick t·∫•t c·∫£ th√†nh vi√™n v·ªÅ lobby
socket.on('hostLeft', () => {
    alert('Ch·ªß ph√≤ng ƒë√£ r·ªùi! Quay v·ªÅ m√†n h√¨nh ch√≠nh.');
    waitingLayer.style.display = 'none';
    gameOverLayer.style.display = 'none';
    lobbyLayer.style.display = 'flex';
    window.roomId = null;
    roomIdInput.value = '';
});

socket.on('joined', (data) => {
    window.playerId = data.playerId;
    window.isP1 = data.isP1;
});

socket.on('gameState', (gameState) => {
    window.gameState = gameState;
    // ·∫®n ph√≤ng ch·ªù khi b·∫Øt ƒë·∫ßu ch∆°i
    waitingLayer.style.display = 'none';
    window.initGame();
});

socket.on('updateState', (gameState) => {
    window.gameState = gameState;
    // X√ìA window.renderGame() v√¨ renderGame ƒëang ch·∫°y trong v√≤ng l·∫∑p requestAnimationFrame b√™n Game.js
});

// Loading flow: images -> sounds -> show lobby
function setLoading(percent, text) {
    loadingProgressBar.style.width = `${percent}%`;
    loadingText.textContent = text;
}

function startLoading() {
    loadingLayer.style.display = 'flex';
    lobbyLayer.style.display = 'none';

    // Load images (0% -> 50%)
    setLoading(0, 'ƒêang t·∫£i h√¨nh ·∫£nh (0%)');
    window.loadImages(() => {
        setLoading(50, 'ƒê√£ t·∫£i h√¨nh ·∫£nh xong (50%)');
        // Load sounds (50% -> 100%)
        const am = new AudioManager();
        window.audioManager = am;
        const soundSources = {
            shoot: 'sounds/shoot.mp3',
            pickup: 'sounds/pickup.mp3',
            bgmusic: 'sounds/bgmusic.mp3'
        };
        am.loadSounds(soundSources, (loaded, total) => {
            const pct = 50 + Math.floor((loaded / total) * 50);
            setLoading(pct, `ƒêang t·∫£i √¢m thanh (${pct}%)`);
        }, () => {
            setLoading(100, 'Ho√†n t·∫•t!');
            // Small delay for UX
            setTimeout(() => {
                loadingLayer.style.display = 'none';
                lobbyLayer.style.display = 'flex';
                window.initUI();
            }, 200);
        });
    }, (loaded, total) => {
        const pct = Math.floor((loaded / total) * 50);
        setLoading(pct, `ƒêang t·∫£i h√¨nh ·∫£nh (${pct}%)`);
    });
}

// Kick off loading on page load
startLoading();

// Controls: d√πng gi√° tr·ªã m·∫∑c ƒë·ªãnh cho m·ªói l·∫ßn t·∫£i trang
// (kh√¥ng l∆∞u v√†o localStorage ƒë·ªÉ m·ªói l·∫ßn m·ªü l·∫°i s·∫Ω reset v·ªÅ WASD + Space)

====================
FILE: Map.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Map.js
====================
// js/Map.js - Phi√™n b·∫£n ƒê·∫¶Y ƒê·ª¶ (D√πng ·∫£nh n·ªÅn + ·∫£nh t∆∞·ªùng)

class GameMap {
    constructor(mapWidth, mapHeight, tileSize) {
        this.width = mapWidth;
        this.height = mapHeight;
        this.tileSize = tileSize;
        this.walls = []; // S·∫Ω ƒë∆∞·ª£c server ƒëi·ªÅn d·ªØ li·ªáu v√†o sau
        this.chunkSize = SharedConstants?.CHUNK_SIZE || 200;
        this.wallChunks = new Map();
        // ƒê√£ x√≥a this.generateMap() v√¨ map do server t·∫°o
    }

    // X√¢y index t∆∞·ªùng theo chunk ƒë·ªÉ truy v·∫•n nhanh (gi·ªëng server)
    buildWallChunks() {
        const chunkSize = this.chunkSize;
        const chunks = new Map();
        const getKey = (cx, cy) => `${cx},${cy}`;
        const toChunk = (x, y) => ({ cx: Math.floor(x / chunkSize), cy: Math.floor(y / chunkSize) });

        this.walls.forEach(wall => {
            const { cx, cy } = toChunk(wall.x, wall.y);
            const key = getKey(cx, cy);
            if (!chunks.has(key)) chunks.set(key, []);
            chunks.get(key).push(wall);
        });

        this.wallChunks = chunks;
    }

    // L·∫•y t∆∞·ªùng g·∫ßn m·ªôt h√¨nh ch·ªØ nh·∫≠t (d√πng cho collision client)
    getWallsNearRect(rect, pad = 10) {
        const chunkSize = this.chunkSize;
        if (!this.wallChunks || this.wallChunks.size === 0) return this.walls || [];

        const startCx = Math.floor(Math.max(0, rect.x - pad) / chunkSize);
        const endCx = Math.floor(Math.min(this.width, rect.x + rect.width + pad) / chunkSize);
        const startCy = Math.floor(Math.max(0, rect.y - pad) / chunkSize);
        const endCy = Math.floor(Math.min(this.height, rect.y + rect.height + pad) / chunkSize);

        const walls = [];
        for (let cy = startCy; cy <= endCy; cy++) {
            for (let cx = startCx; cx <= endCx; cx++) {
                const key = `${cx},${cy}`;
                const arr = this.wallChunks.get(key);
                if (arr) walls.push(...arr);
            }
        }
        return walls;
    }

    // --- H√ÄM V·∫º M·ªöI (D√ôNG ·∫¢NH) ---

    // 1. V·∫Ω n·ªÅn ƒë·∫•t (L√°t g·∫°ch background)
    drawBackground(ctx) {
        // Ki·ªÉm tra xem ·∫£nh ƒë√£ t·∫£i xong ch∆∞a (bi·∫øn IMAGES b√™n main.js)
        if (typeof IMAGES !== 'undefined' && IMAGES.bg) {
            // T·∫°o m·∫´u pattern t·ª´ ·∫£nh ƒë·ªÉ l·∫∑p l·∫°i (gi·ªëng l√°t g·∫°ch s√†n nh√†)
            const pattern = ctx.createPattern(IMAGES.bg, 'repeat');
            ctx.fillStyle = pattern;
            ctx.fillRect(0, 0, this.width, this.height);
        } else {
            // D·ª± ph√≤ng: N·∫øu ch∆∞a c√≥ ·∫£nh th√¨ v·∫Ω m√†u x√°m
            ctx.fillStyle = "#555";
            ctx.fillRect(0, 0, this.width, this.height);
        }
    }
}

====================
FILE: Particle.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Particle.js
====================
class Particle {
    constructor(x, y, vx, vy, color, life, size) {
        this.x = x;
        this.y = y;
        this.vx = vx; // T·ªëc ƒë·ªô X
        this.vy = vy; // T·ªëc ƒë·ªô Y
        this.color = color;
        this.life = life; // Th·ªùi gian s·ªëng (frames)
        this.maxLife = life;
        this.size = size || 3; // K√≠ch th∆∞·ªõc h·∫°t
        this.opacity = 1; // ƒê·ªô trong su·ªët
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.opacity = this.life / this.maxLife; // Gi·∫£m d·∫ßn opacity
        // C√≥ th·ªÉ th√™m l·ª±c h·∫•p d·∫´n ho·∫∑c gi·∫£m t·ªëc ƒë·ªô n·∫øu mu·ªën
        this.vx *= 0.98; // Gi·∫£m t·ªëc ƒë·ªô d·∫ßn
        this.vy *= 0.98;
    }

    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    isDead() {
        return this.life <= 0;
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
        this.maxParticles = 50; // Gi·ªõi h·∫°n 50 particles ƒë·ªÉ t·ªëi ∆∞u
    }

    addParticle(x, y, vx, vy, color, life, size) {
        if (this.particles.length < this.maxParticles) {
            this.particles.push(new Particle(x, y, vx, vy, color, life, size));
        }
    }

    // T·∫°o hi·ªáu ·ª©ng n·ªï (nhi·ªÅu h·∫°t bay ra ng·∫´u nhi√™n)
    createExplosion(x, y, count = 5, color = 'orange', life = 30, speed = 2) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const vx = Math.cos(angle) * speed * (Math.random() * 0.5 + 0.5);
            const vy = Math.sin(angle) * speed * (Math.random() * 0.5 + 0.5);
            this.addParticle(x, y, vx, vy, color, life, Math.random() * 3 + 1);
        }
    }

    // T·∫°o hi·ªáu ·ª©ng b·ª•i (√≠t h·∫°t h∆°n, m√†u n√¢u)
    createDust(x, y, count = 2, color = '#8B4513', life = 20, speed = 1) {
        for (let i = 0; i < count; i++) {
            const vx = (Math.random() - 0.5) * speed;
            const vy = (Math.random() - 0.5) * speed - 0.5; // Bay l√™n m·ªôt ch√∫t
            this.addParticle(x, y, vx, vy, color, life, Math.random() * 2 + 1);
        }
    }

    update() {
        this.particles = this.particles.filter(p => {
            p.update();
            return !p.isDead();
        });
    }

    draw(ctx) {
        this.particles.forEach(p => p.draw(ctx));
    }
}

====================
FILE: Renderer.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Renderer.js
====================
// Renderer.js - H√†m v·∫Ω
function renderPlayerScreen(ctx, canvas, targetTank, gameMap, bullets, tank1, tank2, items, particleSystem, playerData, turrets) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();

    // Camera theo targetTank
    let camX = targetTank.x - canvas.width / 2 + targetTank.width / 2;
    let camY = targetTank.y - canvas.height / 2 + targetTank.height / 2;
    camX = Math.max(0, Math.min(camX, gameMap.width - canvas.width));
    camY = Math.max(0, Math.min(camY, gameMap.height - canvas.height));
    ctx.translate(-camX, -camY);

    // V·∫Ω n·ªÅn ƒë·∫•t
    gameMap.drawBackground(ctx);
    
    // V·∫Ω T∆∞·ªùng: L·∫•y t∆∞·ªùng trong viewport qua chunk index ƒë·ªÉ tr√°nh duy·ªát to√†n b·ªô
    const viewRect = { x: camX, y: camY, width: canvas.width, height: canvas.height };
    const wallsInView = typeof gameMap.getWallsNearRect === 'function'
        ? gameMap.getWallsNearRect(viewRect, 0)
        : gameMap.walls;

    for (let i = 0; i < wallsInView.length; i++) {
        const wall = wallsInView[i];
        if (IMAGES.wall) {
            ctx.drawImage(IMAGES.wall, wall.x, wall.y, wall.width, wall.height);
        } else {
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            ctx.strokeStyle = "black";
            ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
        }
    }
    
    // V·∫Ω turrets (Static enemies)
    if (turrets && turrets.length > 0) {
        turrets.forEach(turret => {
            if (turret.x < camX + canvas.width && turret.x + turret.width > camX && 
                turret.y < camY + canvas.height && turret.y + turret.height > camY) {
                // V·∫Ω turret (h√¨nh vu√¥ng x√°m v·ªõi HP bar)
                ctx.fillStyle = turret.health > 0 ? "#555555" : "#222222";
                ctx.fillRect(turret.x, turret.y, turret.width, turret.height);
                ctx.strokeStyle = "red";
                ctx.lineWidth = 2;
                ctx.strokeRect(turret.x, turret.y, turret.width, turret.height);
                
                // HP bar cho turret
                if (turret.health > 0) {
                    const hpPercent = turret.health / turret.maxHealth;
                    ctx.fillStyle = "black";
                    ctx.fillRect(turret.x, turret.y - 8, turret.width, 6);
                    ctx.fillStyle = hpPercent > 0.3 ? "green" : "red";
                    ctx.fillRect(turret.x, turret.y - 8, turret.width * hpPercent, 6);
                }
            }
        });
    }
    
    // V·∫Ω bullets - Ch·ªâ v·∫Ω trong viewport (t·ªëi ∆∞u culling)
    bullets.forEach(b => {
        if (b.x > camX - 20 && b.x < camX + canvas.width + 20 &&
            b.y > camY - 20 && b.y < camY + canvas.height + 20) {
            b.draw(ctx); // G·ªçi method draw() c·ªßa Bullet instance
        }
    });
    
    // V·∫Ω tank1 (m√¨nh - lu√¥n hi·ªÉn th·ªã)
    if (tank1) {
        // Tank1 l√† m√¨nh, l·∫•y data t·ª´ playerData
        const mySocketId = window.socket?.id;
        const tank1Data = mySocketId && playerData ? playerData[mySocketId] : null;
        
        if (tank1Data && tank1Data.isInvisible) {
            // B·∫£n th√¢n t√†ng h√¨nh: V·∫Ω b√°n trong su·ªët
            ctx.globalAlpha = 0.5;
            tank1.draw(ctx);
            ctx.globalAlpha = 1.0;
        } else {
            tank1.draw(ctx);
        }
        
        // V·∫Ω hi·ªáu ·ª©ng burn (l·ª≠a) n·∫øu c√≥
        if (tank1Data && tank1Data.burnEffect) {
            ctx.fillStyle = "rgba(255, 100, 0, 0.6)";
            ctx.beginPath();
            ctx.arc(tank1.x + tank1.width / 2, tank1.y + tank1.height / 2, tank1.width / 2 + 5, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // V·∫Ω tank2 (ƒë·ªãch - c√≥ th·ªÉ t√†ng h√¨nh)
    if (tank2) {
        // Tank2 l√† ƒë·ªãch, t√¨m socket ID c·ªßa ƒë·ªãch
        const mySocketId = window.socket?.id;
        const enemySocketId = playerData ? Object.keys(playerData).find(sid => sid !== mySocketId) : null;
        const tank2Data = enemySocketId && playerData ? playerData[enemySocketId] : null;
        
        if (tank2Data && tank2Data.isInvisible) {
            // ƒê·ªãch t√†ng h√¨nh: V·∫Ω m·ªù 10% (b√≥ng ma)
            ctx.globalAlpha = 0.1;
            tank2.draw(ctx);
            ctx.globalAlpha = 1.0;
        } else {
            tank2.draw(ctx);
        }
        
        // V·∫Ω hi·ªáu ·ª©ng burn n·∫øu c√≥
        if (tank2Data && tank2Data.burnEffect) {
            ctx.fillStyle = "rgba(255, 100, 0, 0.6)";
            ctx.beginPath();
            ctx.arc(tank2.x + tank2.width / 2, tank2.y + tank2.height / 2, tank2.width / 2 + 5, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // V·∫Ω vi·ªÅn map
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 5;
    ctx.strokeRect(0, 0, gameMap.width, gameMap.height);
    
    // V·∫Ω items (t·ªëi ∆∞u: d√πng forEach thay v√¨ filter)
    items.forEach(item => {
        // Check visibility tr·ª±c ti·∫øp (item c√≥ width/height = 30)
        if (item.x < camX + canvas.width && item.x + 30 > camX && 
            item.y < camY + canvas.height && item.y + 30 > camY) {
            Item.drawRaw(ctx, item);
        }
    });

    // V·∫Ω particles
    particleSystem.draw(ctx);

    ctx.restore(); 

    // HUD - HP (tank1 l√† m√¨nh)
    ctx.fillStyle = "black"; ctx.fillRect(10, 10, 104, 24); 
    let hpPercent = targetTank ? Math.max(0, targetTank.health / targetTank.maxHealth) : 0;
    ctx.fillStyle = hpPercent < 0.3 ? "red" : "#00ff00"; 
    ctx.fillRect(12, 12, 100 * hpPercent, 20);
    ctx.fillStyle = "white"; ctx.font = "bold 12px Arial";
    ctx.fillText(`HP: ${targetTank ? targetTank.health : 0}`, 120, 27);
    
    // Debug info - bullet & particle count
    ctx.fillStyle = "white"; ctx.font = "12px Arial";
    ctx.fillText(`Bullets: ${bullets.length}`, 10, 60);
    ctx.fillText(`Particles: ${particleSystem ? particleSystem.particles.length : 0}`, 10, 80);

    // Buff timers (b√™n g√≥c tr√°i) - L·∫•y data c·ªßa tank1 (m√¨nh)
    const mySocketId = window.socket?.id;
    const myData = mySocketId && playerData ? playerData[mySocketId] : null;
    if (myData && myData.buffTimers) {
        const timers = myData.buffTimers;
        const entries = [
            { key: 'speed', label: 'T·ªëc ƒë·ªô' },
            { key: 'shield', label: 'Gi√°p' },
            { key: 'fireAmmo', label: 'ƒê·∫°n l·ª≠a' },
            { key: 'clusterAmmo', label: 'ƒê·∫°n ch√πm' },
            { key: 'stealth', label: 'T√†ng h√¨nh' }
        ];
        let line = 0;
        ctx.font = "12px Arial";
        entries.forEach(entry => {
            const val = timers[entry.key];
            if (val && val > 0) {
                const sec = Math.ceil(val / 60);
                ctx.fillStyle = "white";
                ctx.fillText(`${entry.label}: ${sec}s`, 10, 100 + line * 16);
                line++;
            }
        });
        
        // Burn effect timer
        if (myData.burnEffect) {
            const sec = Math.ceil(myData.burnEffect.duration / 60);
            ctx.fillStyle = "orange";
            ctx.fillText(`üî• ƒêang ch√°y: ${sec}s`, 10, 100 + line * 16);
        }
    }
}

// Global
window.renderPlayerScreen = renderPlayerScreen;

// === MINI-MAP RENDERING ===
function renderMiniMap(minimapCanvas, gameMap, targetTank, players, turrets, items) {
    if (!minimapCanvas) return;
    
    const ctx = minimapCanvas.getContext('2d');
    const mapW = gameMap.width;
    const mapH = gameMap.height;
    const scale = minimapCanvas.width / mapW; // 200 / 2400 = 1/12
    
    // Clear mini-map
    ctx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
    
    // V·∫Ω background
    ctx.fillStyle = "rgba(50, 50, 50, 0.8)";
    ctx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
    
    // V·∫Ω vi·ªÅn
    ctx.strokeStyle = "#ffc107";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, minimapCanvas.width, minimapCanvas.height);
    
    // V·∫Ω turrets (ch·∫•m x√°m)
    if (turrets) {
        turrets.forEach(turret => {
            if (turret.health > 0) {
                const x = turret.x * scale + turret.width * scale / 2;
                const y = turret.y * scale + turret.height * scale / 2;
                ctx.fillStyle = "#888888";
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }
    
    // V·∫Ω items (ch·∫•m v√†ng nh·ªè)
    if (items && items.length > 0) {
        items.forEach(item => {
            const x = item.x * scale + 15 * scale;
            const y = item.y * scale + 15 * scale;
            ctx.fillStyle = "rgba(255, 215, 0, 0.6)";
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // V·∫Ω players
    if (players) {
        Object.entries(players).forEach(([socketId, player]) => {
            if (player.health <= 0) return;
            
            const x = player.x * scale + player.width * scale / 2;
            const y = player.y * scale + player.height * scale / 2;
            
            // Check t√†ng h√¨nh
            if (player.isInvisible && socketId !== window.socket?.id) {
                // ƒê·ªãch t√†ng h√¨nh: Kh√¥ng hi·ªÉn th·ªã tr√™n mini-map
                return;
            }
            
            // D√πng player.id ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng: p1 xanh, p2 ƒë·ªè
            if (player.id === 'p1') {
                ctx.fillStyle = "#00ff00"; // Xanh = P1
            } else {
                ctx.fillStyle = "#ff0000"; // ƒê·ªè = P2
            }
            
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // V·∫Ω vi·ªÅn ƒë·ªÉ n·ªïi b·∫≠t
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }
}

window.renderMiniMap = renderMiniMap;

====================
FILE: Tank.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Tank.js
====================
class Tank {
    constructor(x, y, imageKey, id) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.width = SharedConstants.TANK_WIDTH;
        this.height = SharedConstants.TANK_HEIGHT;
        
        // Interpolation (Lerp) cho chuy·ªÉn ƒë·ªông m∆∞·ª£t m√†
        this.targetX = x; // V·ªã tr√≠ ƒë√≠ch t·ª´ server
        this.targetY = y;
        this.lerpFactor = SharedConstants.LERP_FACTOR; // T·ªëc ƒë·ªô lerp t·ª´ SharedConstants
        
        this.image = IMAGES[imageKey]; 
        
        this.maxHealth = SharedConstants.PLAYER_MAX_HEALTH;
        this.health = SharedConstants.PLAYER_MAX_HEALTH;
        this.shield = SharedConstants.PLAYER_BASE_SHIELD;
        this.damage = SharedConstants.PLAYER_BASE_DAMAGE;
        this.bulletType = 1;
        this.speed = SharedConstants.TANK_BASE_SPEED;
        
        this.lastDx = 0; 
        this.lastDy = -1;

        this.keys = { up: false, down: false, left: false, right: false, shoot: false };
        this.canShoot = true;
        this.controlsSetup = false; // Flag ƒë·ªÉ ch·ªâ setup 1 l·∫ßn
        
        // Input throttling ƒë·ªÉ tr√°nh spam socket.emit cho movement
        this.lastInputSendTime = 0;
        this.inputSendInterval = 1000 / SharedConstants.INPUT_THROTTLE_RATE; // ms t·ª´ SharedConstants
        
        // Movement priority: Track th·ª© t·ª± ph√≠m nh·∫•n ƒë·ªÉ x·ª≠ l√Ω multi-key input t·ªët h∆°n
        this.movementPriority = []; // Array ch·ª©a c√°c ph√≠m movement ƒëang ƒë∆∞·ª£c nh·∫•n theo th·ª© t·ª±
        this.lastSentPriority = []; // Track priority ƒë√£ g·ª≠i l√™n server
        
        // === CLIENT-SIDE PREDICTION ===
        // V·ªã tr√≠ predicted (client t·ª± t√≠nh, kh√¥ng ch·ªù server)
        this.predictedX = x;
        this.predictedY = y;
        
        // V·ªã tr√≠ cu·ªëi c√πng nh·∫≠n t·ª´ server (ƒë·ªÉ reconcile)
        this.lastServerX = x;
        this.lastServerY = y;
        
        // Queue input ch∆∞a ƒë∆∞·ª£c reconcile t·ª´ server
        this.pendingInputs = []; // [{dx, dy, speed, seq}]
        this.inputSequenceNumber = 0; // Sequence number cho m·ªói input g·ª≠i l√™n server
        
        // Threshold ƒë·ªÉ detect l·ªách qu√° xa (reconciliation)
        this.reconciliationThreshold = SharedConstants.SNAP_THRESHOLD; // D√πng l·∫°i SNAP_THRESHOLD
    }

    resetInput() {
        this.keys = { up: false, down: false, left: false, right: false, shoot: false };
        this.canShoot = true;
    }

  setupControls() {
    // Ch·ªâ setup 1 l·∫ßn, tr√°nh l·∫∑p listeners
    if (this.controlsSetup) return;
    this.controlsSetup = true;
    
    // L·∫•y controls t·ª´ settings c·ªßa session hi·ªán t·∫°i ho·∫∑c d√πng m·∫∑c ƒë·ªãnh
    const controls = window.controlsP1 || { up: 'w', down: 's', left: 'a', right: 'd', shoot: ' ' };

    // Helper g·ª≠i input k√®m seq v√† apply predicted movement t∆∞∆°ng ·ª©ng
    const sendInput = () => {
        if (!window.socket) return;
        const now = Date.now();
        const { dx, dy } = this.predictMovement(this.movementPriority);
        const seq = this.inputSequenceNumber++;
        const moveSpeed = this.speed || SharedConstants.TANK_BASE_SPEED;
        const input = { ...this.keys, priority: this.movementPriority, seq };
        window.socket.emit('playerInput', { roomId: window.roomId || 'default', input });
        this.lastInputSendTime = now;
        this.lastSentPriority = [...this.movementPriority];

        // Apply predicted movement cho input v·ª´a g·ª≠i
        if (dx !== 0 || dy !== 0) {
            this.applyPredictedMovement(dx, dy, moveSpeed, { seq });
            this.lastDx = dx;
            this.lastDy = dy;
        }
    };
    
    window.addEventListener('keydown', (e) => {
        const oldKeys = JSON.stringify(this.keys);
        const wasShoot = this.keys.shoot;
        
        // Movement keys v·ªõi priority tracking
        if (e.key === controls.up && !this.keys.up) {
            this.keys.up = true;
            // X√≥a 'up' kh·ªèi array n·∫øu c√≥ (tr√°nh duplicate), r·ªìi th√™m v√†o cu·ªëi
            this.movementPriority = this.movementPriority.filter(k => k !== 'up');
            this.movementPriority.push('up');
        }
        if (e.key === controls.down && !this.keys.down) {
            this.keys.down = true;
            this.movementPriority = this.movementPriority.filter(k => k !== 'down');
            this.movementPriority.push('down');
        }
        if (e.key === controls.left && !this.keys.left) {
            this.keys.left = true;
            this.movementPriority = this.movementPriority.filter(k => k !== 'left');
            this.movementPriority.push('left');
        }
        if (e.key === controls.right && !this.keys.right) {
            this.keys.right = true;
            this.movementPriority = this.movementPriority.filter(k => k !== 'right');
            this.movementPriority.push('right');
        }
        
        if (e.key === controls.shoot) {
            this.keys.shoot = true;
            // === AUDIO OVERLAPPING ===
            // allowOverlap = true ƒë·ªÉ cho ti·∫øng s√∫ng ch·ªìng l√™n nhau (clone method)
            if (!wasShoot && window.audioManager) window.audioManager.playSound('shoot', false, true);
        }
        
        const now = Date.now();
        const priorityChanged = JSON.stringify(this.movementPriority) !== JSON.stringify(this.lastSentPriority || []);
        const keysChanged = JSON.stringify(this.keys) !== oldKeys;

        if (keysChanged || priorityChanged) {
            // G·ª≠i ngay n·∫øu b·∫Øn ho·∫∑c priority ƒë·ªïi; n·∫øu kh√¥ng th√¨ throttle 33ms
            if (e.key === controls.shoot || priorityChanged || (now - this.lastInputSendTime >= this.inputSendInterval)) {
                sendInput();
            }
        }
    });
    window.addEventListener('keyup', (e) => {
        const oldKeys = JSON.stringify(this.keys);
        
        // Movement keys v·ªõi priority tracking
        if (e.key === controls.up) {
            this.keys.up = false;
            this.movementPriority = this.movementPriority.filter(k => k !== 'up');
        }
        if (e.key === controls.down) {
            this.keys.down = false;
            this.movementPriority = this.movementPriority.filter(k => k !== 'down');
        }
        if (e.key === controls.left) {
            this.keys.left = false;
            this.movementPriority = this.movementPriority.filter(k => k !== 'left');
        }
        if (e.key === controls.right) {
            this.keys.right = false;
            this.movementPriority = this.movementPriority.filter(k => k !== 'right');
        }
        
        if (e.key === controls.shoot) {
            this.keys.shoot = false;
            this.canShoot = true;
        }
        
        const now = Date.now();
        const priorityChanged = JSON.stringify(this.movementPriority) !== JSON.stringify(this.lastSentPriority || []);
        const keysChanged = JSON.stringify(this.keys) !== oldKeys;

        if (keysChanged || priorityChanged) {
            if (e.key === controls.shoot || priorityChanged || (now - this.lastInputSendTime >= this.inputSendInterval)) {
                sendInput();
            }
        }
    });
  }

    // Update from server data
    updateFromData(data) {
        // Thay v√¨ g√°n c·ª©ng t·ªça ƒë·ªô (this.x = data.x), ta l∆∞u v√†o targetX/targetY
        // Sau ƒë√≥ trong update() s·∫Ω lerp t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn target
        this.targetX = data.x;
        this.targetY = data.y;
        
        // Server reconciliation: reset v·ªÅ server r·ªìi replay c√°c input ch∆∞a ƒë∆∞·ª£c server x·ª≠ l√Ω
        const lastAckSeq = typeof data.lastProcessedInputSeq === 'number' ? data.lastProcessedInputSeq : -1;

        // B·ªè c√°c input ƒë√£ ƒë∆∞·ª£c server x·ª≠ l√Ω
        this.pendingInputs = this.pendingInputs.filter(inp => inp.seq > lastAckSeq);

        // Re-simulate c√°c input c√≤n l·∫°i t·ª´ v·ªã tr√≠ server
        let reconciledX = data.x;
        let reconciledY = data.y;
        for (const inp of this.pendingInputs) {
            const step = this.simulateMovementStep(reconciledX, reconciledY, inp.dx, inp.dy, inp.speed);
            reconciledX = step.x;
            reconciledY = step.y;
        }

        this.predictedX = reconciledX;
        this.predictedY = reconciledY;
        this.lastServerX = data.x;
        this.lastServerY = data.y;
        
        // C√°c thu·ªôc t√≠nh kh√°c v·∫´n c·∫≠p nh·∫≠t ngay l·∫≠p t·ª©c
        this.speed = data.speed || SharedConstants.TANK_BASE_SPEED;
        this.health = data.health;
        this.shield = data.shield;
        this.damage = data.damage;
        this.bulletType = data.bulletType;
        this.lastDx = data.lastDx;
        this.lastDy = data.lastDy;
    }
    
    // === CLIENT-SIDE PREDICTION ===
    // H√†m n√†y ƒë∆∞·ª£c g·ªçi trong setupControls ƒë·ªÉ predict movement
    predictMovement(priority) {
        let dx = 0, dy = 0;
        
        // X·ª≠ l√Ω priority th·ª© t·ª± ph√≠m (t·ª´ m·ªõi nh·∫•t)
        if (priority.length > 0) {
            let verticalSet = false;
            let horizontalSet = false;
            
            for (let i = priority.length - 1; i >= 0; i--) {
                const key = priority[i];
                
                if (!verticalSet) {
                    if (key === 'up') { dy = -1; verticalSet = true; }
                    else if (key === 'down') { dy = 1; verticalSet = true; }
                }
                
                if (!horizontalSet) {
                    if (key === 'left') { dx = -1; horizontalSet = true; }
                    else if (key === 'right') { dx = 1; horizontalSet = true; }
                }
                
                if (verticalSet && horizontalSet) break;
            }
        }
        
        return { dx, dy };
    }
    
    // T√≠nh m·ªôt b∆∞·ªõc di chuy·ªÉn (d√πng cho prediction v√† replay)
    simulateMovementStep(baseX, baseY, dx, dy, speed) {
        if (dx === 0 && dy === 0) return { x: baseX, y: baseY };

        // N·∫øu gameMap ch∆∞a kh·ªüi t·∫°o, b·ªè qua collision
        if (typeof gameMap === 'undefined') {
            return { x: baseX + dx * speed, y: baseY + dy * speed };
        }

        let newX = baseX + dx * speed;
        let newY = baseY + dy * speed;

        // Boundary
        newX = Math.max(0, Math.min(newX, gameMap.width - this.width));
        newY = Math.max(0, Math.min(newY, gameMap.height - this.height));

        // Collision check (gi·∫£m t·∫£i b·∫±ng filter g·∫ßn v·ªã tr√≠ m·ªõi)
        const testHitbox = {
            x: newX + SharedConstants.TANK_HITBOX_PADDING,
            y: newY + SharedConstants.TANK_HITBOX_PADDING,
            width: this.width - SharedConstants.TANK_HITBOX_PADDING * 2,
            height: this.height - SharedConstants.TANK_HITBOX_PADDING * 2
        };

        // L·∫•y t∆∞·ªùng g·∫ßn b·∫±ng chunk index n·∫øu c√≥, fallback filter nh·∫π
        let nearbyWalls = [];
        if (typeof gameMap.getWallsNearRect === 'function') {
            nearbyWalls = gameMap.getWallsNearRect(testHitbox, 10);
        } else if (gameMap.walls) {
            nearbyWalls = gameMap.walls.filter(wall =>
                Math.abs(wall.x - newX) < 150 && Math.abs(wall.y - newY) < 150
            );
        }

        for (let wall of nearbyWalls) {
            if (SharedUtils.isColliding(testHitbox, wall)) {
                return { x: baseX, y: baseY }; // va ch·∫°m -> kh√¥ng di chuy·ªÉn
            }
        }

        return { x: newX, y: newY };
    }

    // Apply predicted movement ngay l·∫≠p t·ª©c (tu·ª≥ ch·ªçn push v√†o pending queue)
    applyPredictedMovement(dx, dy, speed = SharedConstants.TANK_BASE_SPEED, options = {}) {
        if (dx === 0 && dy === 0) return;

        const { x, y } = this.simulateMovementStep(this.predictedX, this.predictedY, dx, dy, speed);
        this.predictedX = x;
        this.predictedY = y;

        if (!options.skipQueue && typeof options.seq === 'number') {
            this.pendingInputs.push({
                seq: options.seq,
                dx,
                dy,
                speed
            });
        }
    }

    // Update ƒë∆°n gi·∫£n cho tank ƒë·ªãch (kh√¥ng prediction, ch·ªâ lerp)
    updateSimple() {
        // Lerp t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn target (kh√¥ng prediction)
        this.x += (this.targetX - this.x) * this.lerpFactor;
        this.y += (this.targetY - this.y) * this.lerpFactor;
        
        // Snap n·∫øu qu√° g·∫ßn
        if (Math.abs(this.targetX - this.x) < 0.5) this.x = this.targetX;
        if (Math.abs(this.targetY - this.y) < 0.5) this.y = this.targetY;
    }
    
    // H√†m lerp ƒë·ªÉ interpolate v·ªã tr√≠ m·ªói frame v·ªõi Snap Logic
    update() {
        // === CONTINUOUS CLIENT-SIDE PREDICTION (M·ªói Frame) ===
        // N·∫øu c√≥ ph√≠m di chuy·ªÉn ƒë∆∞·ª£c nh·∫•n, predict li√™n t·ª•c
        const { dx, dy } = this.predictMovement(this.movementPriority);
        const moveSpeed = this.speed || SharedConstants.TANK_BASE_SPEED;
        if (dx !== 0 || dy !== 0) {
            this.applyPredictedMovement(dx, dy, moveSpeed, { skipQueue: true });
            this.lastDx = dx;
            this.lastDy = dy;
        }
        
        // === DISPLAY: D√πng PREDICTED position thay v√¨ SERVER position ===
        // ƒêi·ªÅu n√†y l√†m xe di chuy·ªÉn ngay l·∫≠p t·ª©c theo client prediction
        // this.x v√† this.y l√† position d√πng ƒë·ªÉ v·∫Ω
        
        // Lerp gi·ªØa predicted position v√† target position (t·ª´ server)
        // N·∫øu predicted kh√° ch√≠nh x√°c th√¨ lerp s·∫Ω r·∫•t nh·ªè
        const distanceToTarget = SharedUtils.distance(this.predictedX, this.predictedY, this.targetX, this.targetY);
        
        if (distanceToTarget > this.reconciliationThreshold) {
            // L·ªách qu√° xa: Snap c·ª©ng
            this.predictedX = this.targetX;
            this.predictedY = this.targetY;
        } else {
            // L·ªách nh·ªè: Lerp m∆∞·ª£t m√†
            this.predictedX += (this.targetX - this.predictedX) * this.lerpFactor;
            this.predictedY += (this.targetY - this.predictedY) * this.lerpFactor;
            
            if (Math.abs(this.targetX - this.predictedX) < 0.5) this.predictedX = this.targetX;
            if (Math.abs(this.targetY - this.predictedY) < 0.5) this.predictedY = this.targetY;
        }
        
        // G√°n predicted position v√†o display position
        this.x = this.predictedX;
        this.y = this.predictedY;
    }

    draw(ctx) {
        // T√≠nh to√°n g√≥c quay (Angle)
        // Math.atan2 tr·∫£ v·ªÅ g√≥c t√≠nh b·∫±ng radian
        let angle = Math.atan2(this.lastDy, this.lastDx);
        
        // ƒêi·ªÅu ch·ªânh g√≥c: V√¨ ·∫£nh m·∫∑c ƒë·ªãnh h∆∞·ªõng l√™n (UP), 
        // nh∆∞ng atan2 t√≠nh g√≥c 0 l√† b√™n ph·∫£i (RIGHT).
        // Ta c·∫ßn c·ªông th√™m 90 ƒë·ªô (PI/2) ƒë·ªÉ kh·ªõp.
        angle += Math.PI / 2;

        ctx.save();
        
        // D·ªãch chuy·ªÉn g·ªëc t·ªça ƒë·ªô v·ªÅ T√ÇM c·ªßa xe tƒÉng
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        
        // Xoay
        ctx.rotate(angle);

        // V·∫Ω ·∫£nh (L√πi v·ªÅ -width/2, -height/2 ƒë·ªÉ v·∫Ω ƒë√∫ng t√¢m)
        if (this.image) {
            ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
        } else {
            // D·ª± ph√≤ng n·∫øu ·∫£nh l·ªói th√¨ v·∫Ω h√¨nh vu√¥ng
            ctx.fillStyle = this.id === "p1" ? "red" : "blue";
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        }

        ctx.restore();
    }
}

====================
FILE: UIManager.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\UIManager.js
====================
// UIManager.js - Qu·∫£n l√Ω UI v√† menu

function initUI() {
    const lobbyLayer = document.getElementById('lobby-layer');
    const settingsLayer = document.getElementById('settings-layer');
    const gameOverLayer = document.getElementById('game-over-layer');
    const settingsBtn = document.getElementById('settingsBtn');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const backToLobbyBtn = document.getElementById('backToLobbyBtn');
    const homeBtn = document.getElementById('homeBtn');

    // Load controls cho session hi·ªán t·∫°i (kh√¥ng d√πng localStorage)
    loadControls();

    // N√öT M·ªû SETTINGS
    settingsBtn.addEventListener('click', () => {
        lobbyLayer.style.display = 'none';
        settingsLayer.style.display = 'flex';
    });

    // N√öT L∆ØU C√ÄI ƒê·∫∂T
    saveSettingsBtn.addEventListener('click', () => {
        saveControls();
        alert('ƒê√£ l∆∞u c√†i ƒë·∫∑t ph√≠m!');
        settingsLayer.style.display = 'none';
        lobbyLayer.style.display = 'flex';
    });

    // N√öT QUAY L·∫†I T·ª™ SETTINGS
    backToLobbyBtn.addEventListener('click', () => {
        settingsLayer.style.display = 'none';
        lobbyLayer.style.display = 'flex';
    });

    // N√öT M√ÄN H√åNH CH√çNH: R·ªùi ph√≤ng v√† quay v·ªÅ lobby
    homeBtn.addEventListener('click', () => {
        gameOverLayer.style.display = 'none';
        if (window.socket && window.roomId) {
            window.socket.emit('leaveRoom', { roomId: window.roomId });
        }
        location.reload();
    });
}

// H√†m load controls cho session hi·ªán t·∫°i (reset v·ªÅ m·∫∑c ƒë·ªãnh khi reload)
function loadControls() {
    const controls = window.controlsP1 || { up: 'w', down: 's', left: 'a', right: 'd', shoot: ' ' };
    document.getElementById('control-up').value = controls.up;
    document.getElementById('control-down').value = controls.down;
    document.getElementById('control-left').value = controls.left;
    document.getElementById('control-right').value = controls.right;
    document.getElementById('control-shoot').value = controls.shoot;
    window.controlsP1 = controls; // gi·ªØ trong RAM cho t·ªõi khi refresh
}

// H√†m save controls cho session hi·ªán t·∫°i (kh√¥ng l∆∞u localStorage)
function saveControls() {
    const controls = {
        up: document.getElementById('control-up').value,
        down: document.getElementById('control-down').value,
        left: document.getElementById('control-left').value,
        right: document.getElementById('control-right').value,
        shoot: document.getElementById('control-shoot').value
    };
    window.controlsP1 = controls;
}

// Global
window.initUI = initUI;
window.loadControls = loadControls;
window.saveControls = saveControls;

====================
FILE: Utils.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\js\Utils.js
====================
// Utils.js - C√°c h√†m ti·ªán √≠ch
// File n√†y hi·ªán t·∫°i s·ª≠ d·ª•ng SharedUtils.js ƒë·ªÉ c√≥ c√°c h√†m utility chung v·ªõi server
// ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o logic nh·∫•t qu√°n gi·ªØa client v√† server (Client-side Prediction)

// SharedUtils ƒë√£ ƒë∆∞·ª£c load qua index.html, c√≥ th·ªÉ truy c·∫≠p qua window.SharedUtils

====================
FILE: server.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\server\server.js
====================
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const path = require('path');

// Import shared constants and utils
const SharedConstants = require('../shared/SharedConstants.js');
const SharedUtils = require('../shared/SharedUtils.js');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: { origin: "*" },
  pingInterval: 10000,    // Ping every 10s
  pingTimeout: 30000,     // Wait 30s for pong before disconnect
  maxHttpBufferSize: 1e6  // 1MB buffer
});

const PORT = process.env.PORT || 3000;

// Serve static files (client)
app.use(express.static(path.join(__dirname, '..')));

// Game state per room
let games = new Map(); // roomId -> game state

// Copy map generation from Map.js (simplified)
function generateMap() {
  const walls = [];
  const mapWidth = SharedConstants.MAP_WIDTH;
  const mapHeight = SharedConstants.MAP_HEIGHT;
  const tileSize = SharedConstants.TILE_SIZE;
  const chunkSize = SharedConstants.CHUNK_SIZE; // Chunk 200x200 to reduce collision checks
  const cols = mapWidth / tileSize;
  const rows = mapHeight / tileSize;

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      let isBorder = (row === 0 || row === rows - 1 || col === 0 || col === cols - 1);
      let isObstacle = Math.random() < SharedConstants.MAP_OBSTACLE_DENSITY;
      let safeZoneP1 = (col < SharedConstants.MAP_SAFE_ZONE_SIZE && row < SharedConstants.MAP_SAFE_ZONE_SIZE);
      let safeZoneP2 = (col > cols - (SharedConstants.MAP_SAFE_ZONE_SIZE + 1) && row > rows - (SharedConstants.MAP_SAFE_ZONE_SIZE + 1));

      if (isBorder || (isObstacle && !safeZoneP1 && !safeZoneP2)) {
        walls.push({
          x: col * tileSize,
          y: row * tileSize,
          width: tileSize,
          height: tileSize
        });
      }
    }
  }
  const map = { width: mapWidth, height: mapHeight, walls, tileSize, chunkSize };
  buildWallChunks(map);
  return map;
}

// Build a chunk index for walls to speed up collision checks
function buildWallChunks(map) {
  const chunks = new Map();
  const getKey = (cx, cy) => `${cx},${cy}`;
  const toChunk = (x, y) => ({ cx: Math.floor(x / map.chunkSize), cy: Math.floor(y / map.chunkSize) });
  for (let wall of map.walls) {
    const { cx, cy } = toChunk(wall.x, wall.y);
    const key = getKey(cx, cy);
    if (!chunks.has(key)) chunks.set(key, []);
    chunks.get(key).push(wall);
  }
  map.wallChunks = chunks;
}

// Generate turrets (Static AI enemies)
function generateTurrets(map) {
  const turrets = [];
  const count = SharedConstants.TURRET_COUNT;
  const mapW = map.width;
  const mapH = map.height;
  const tileSize = SharedConstants.TILE_SIZE;
  const safeTiles = SharedConstants.MAP_SAFE_ZONE_SIZE;
  const safeSize = safeTiles * tileSize;
  const margin = 50; // th√™m kho·∫£ng c√°ch ƒë·ªÉ tr√°nh s√°t m√©p spawn

  // Safe zones quanh spawn ng∆∞·ªùi ch∆°i (tr√°nh ƒë·∫∑t turret ·ªü ƒë√¢y)
  const safeZones = [
    { x: 0, y: 0, width: safeSize + margin, height: safeSize + margin }, // G√≥c tr√™n tr√°i (P1)
    { x: mapW - (safeSize + margin), y: mapH - (safeSize + margin), width: safeSize + margin, height: safeSize + margin } // G√≥c d∆∞·ªõi ph·∫£i (P2)
  ];

  const isInSafeZone = (x, y, size) => {
    const rect = { x, y, width: size, height: size };
    return safeZones.some(zone => SharedUtils.isColliding(rect, zone));
  };
  
  // Chia map th√†nh 4 zones, m·ªói zone c√≥ 2 turrets
  const zones = [
    { x: 0, y: 0, w: mapW / 2, h: mapH / 2 },           // Top-left
    { x: mapW / 2, y: 0, w: mapW / 2, h: mapH / 2 },    // Top-right
    { x: 0, y: mapH / 2, w: mapW / 2, h: mapH / 2 },    // Bottom-left
    { x: mapW / 2, y: mapH / 2, w: mapW / 2, h: mapH / 2 } // Bottom-right
  ];
  
  let turretId = 0;
  for (let zone of zones) {
    // Spawn 2 turrets m·ªói zone
    for (let i = 0; i < 2; i++) {
      let x, y, attempts = 0;
      do {
        x = zone.x + Math.random() * zone.w;
        y = zone.y + Math.random() * zone.h;
        attempts++;
      } while (
        attempts < 50 && (
          isInSafeZone(x, y, SharedConstants.TURRET_SIZE) ||
          map.walls.some(wall =>
            SharedUtils.isColliding(
              { x, y, width: SharedConstants.TURRET_SIZE, height: SharedConstants.TURRET_SIZE },
              wall
            )
          )
        )
      );
      
      if (attempts < 50) {
        turrets.push({
          id: `turret_${turretId++}`,
          x,
          y,
          width: SharedConstants.TURRET_SIZE,
          height: SharedConstants.TURRET_SIZE,
          health: SharedConstants.TURRET_MAX_HEALTH,
          maxHealth: SharedConstants.TURRET_MAX_HEALTH,
          damage: SharedConstants.TURRET_DAMAGE,
          range: SharedConstants.TURRET_RANGE,
          lastShootTime: 0,
          shootCooldown: SharedConstants.TURRET_SHOOT_COOLDOWN
        });
      }
    }
  }
  
  return turrets;
}

// Create cluster fragments (6 bullets in 360 degrees)
function createClusterFragments(game, bullet) {
  const fragmentCount = SharedConstants.BUFF_VALUES.CLUSTER_FRAG_COUNT || 6;
  const fragmentDamage = SharedConstants.BUFF_VALUES.CLUSTER_FRAG_DAMAGE || 10;
  const angleStep = (Math.PI * 2) / fragmentCount;
  
  for (let i = 0; i < fragmentCount; i++) {
    const angle = angleStep * i;
    const dx = Math.cos(angle);
    const dy = Math.sin(angle);
    
    game.bullets.push({
      id: game.bulletSeq++,
      x: bullet.x,
      y: bullet.y,
      dx: dx,
      dy: dy,
      speed: SharedConstants.BULLET_SPEED * 0.6, // Ch·∫≠m h∆°n ƒë·∫°n th∆∞·ªùng
      ownerId: bullet.ownerId,
      damage: fragmentDamage,
      type: 1, // ƒê·∫°n th∆∞·ªùng
      width: SharedConstants.BULLET_WIDTH * 0.7,
      height: SharedConstants.BULLET_HEIGHT * 0.7,
      isFragment: true,
      lifespan: 30 // ~0.5 gi√¢y ·ªü 60fps
    });
  }
}

// Get walls near a rectangle using chunk index
function getWallsNear(map, rect) {
  const pad = 10;
  const startCx = Math.floor(Math.max(0, rect.x - pad) / map.chunkSize);
  const endCx = Math.floor(Math.min(map.width, rect.x + rect.width + pad) / map.chunkSize);
  const startCy = Math.floor(Math.max(0, rect.y - pad) / map.chunkSize);
  const endCy = Math.floor(Math.min(map.height, rect.y + rect.height + pad) / map.chunkSize);
  const walls = [];
  for (let cy = startCy; cy <= endCy; cy++) {
    for (let cx = startCx; cx <= endCx; cx++) {
      const key = `${cx},${cy}`;
      const arr = map.wallChunks.get(key);
      if (arr) walls.push(...arr);
    }
  }
  return walls;
}

// Create cluster fragments (6 ƒë·∫°n con to·∫£ 360 ƒë·ªô)
function createClusterFragments(game, bullet) {
  const fragmentCount = SharedConstants.BUFF_VALUES.CLUSTER_FRAG_COUNT;
  const fragmentDamage = SharedConstants.BUFF_VALUES.CLUSTER_FRAG_DAMAGE;
  const angleStep = (Math.PI * 2) / fragmentCount;
  
  for (let i = 0; i < fragmentCount; i++) {
    const angle = angleStep * i;
    game.bullets.push({
      id: game.bulletSeq++,
      x: bullet.x,
      y: bullet.y,
      dx: Math.cos(angle),
      dy: Math.sin(angle),
      speed: SharedConstants.BULLET_SPEED * 0.7, // Ch·∫≠m h∆°n ƒë·∫°n g·ªëc
      ownerId: bullet.ownerId,
      damage: fragmentDamage,
      type: 1, // ƒê·∫°n con l√† ƒë·∫°n th∆∞·ªùng
      width: SharedConstants.BULLET_WIDTH * 0.7,
      height: SharedConstants.BULLET_HEIGHT * 0.7,
      isFragment: true, // ƒê√°nh d·∫•u l√† ƒë·∫°n con
      lifespan: 30 // Ch·ªâ s·ªëng 30 frames (~0.5s)
    });
  }
}

// Item spawning logic (simplified)
let itemSpawnTimer = 0;
function spawnItems(game) {
  itemSpawnTimer++;
  if (itemSpawnTimer >= SharedConstants.ITEM_SPAWN_INTERVAL) { // Spawn every 2 seconds (120 frames at 60fps)
    itemSpawnTimer = 0;
    // Count current items (6 types m·ªõi)
    let count = [0, 0, 0, 0, 0, 0];
    game.items.forEach(item => count[item.type - 1]++);

    const itemTargets = [
      SharedConstants.ITEM_TARGETS.HEALTH,
      SharedConstants.ITEM_TARGETS.SPEED,
      SharedConstants.ITEM_TARGETS.SHIELD,
      SharedConstants.ITEM_TARGETS.FIRE_AMMO,
      SharedConstants.ITEM_TARGETS.CLUSTER_AMMO,
      SharedConstants.ITEM_TARGETS.STEALTH
    ];
    let totalMissing = 0;
    for (let i = 0; i < 6; i++) {
      totalMissing += Math.max(0, itemTargets[i] - count[i]);
    }
    if (totalMissing === 0) return;

    let spawnCount = Math.min(3, totalMissing);
    for (let i = 0; i < spawnCount; i++) {
      let selectedType = -1;
      let maxMissing = 0;
      for (let j = 0; j < 6; j++) {
        let missing = itemTargets[j] - count[j];
        if (missing > maxMissing) {
          maxMissing = missing;
          selectedType = j + 1;
        }
      }
      if (selectedType === -1) break;
      count[selectedType - 1]++;

      let x, y, attempts = 0;
      do {
        x = Math.random() * game.map.width;
        y = Math.random() * game.map.height;
        attempts++;
      } while (attempts < 20 && game.map.walls.some(wall => 
        SharedUtils.isColliding({x, y, width: SharedConstants.ITEM_SIZE, height: SharedConstants.ITEM_SIZE}, wall)
      ));

      if (attempts < 20) {
        game.items.push({ x, y, type: selectedType });
      }
    }
  }
}

io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);

  // T·∫°o ph√≤ng m·ªõi
  socket.on('createRoom', (data) => {
    const { roomId } = data;
    if (games.has(roomId)) {
      socket.emit('roomNotFound');
      return;
    }
    
    socket.join(roomId);
    const gameMap = generateMap();
    games.set(roomId, {
      players: {},
      bullets: [],
      items: [],
      turrets: generateTurrets(gameMap), // Th√™m turrets
      map: gameMap,
      isGameOver: false,
      winner: null,
      bulletSeq: 1,
      hostId: socket.id, // L∆∞u host
      isPlaying: false // Tr·∫°ng th√°i game
    });
    
    const game = games.get(roomId);
    const isP1 = true;
    game.players[socket.id] = {
      id: 'p1',
      x: SharedConstants.PLAYER_P1_SPAWN.x,
      y: SharedConstants.PLAYER_P1_SPAWN.y,
      width: SharedConstants.TANK_WIDTH,
      height: SharedConstants.TANK_HEIGHT,
      speed: SharedConstants.TANK_BASE_SPEED,
      health: SharedConstants.PLAYER_MAX_HEALTH,
      maxHealth: SharedConstants.PLAYER_MAX_HEALTH,
      shield: SharedConstants.PLAYER_BASE_SHIELD,
      damage: SharedConstants.PLAYER_BASE_DAMAGE,
      bulletType: 1,
      lastDx: 0,
      lastDy: -1,
      angle: 0,
      keys: { up: false, down: false, left: false, right: false, shoot: false, priority: [] },
      canShoot: true,
      lastShootTime: 0,
      shootCooldown: SharedConstants.SHOOT_COOLDOWN,
      defaultSpeed: SharedConstants.TANK_BASE_SPEED,
      defaultDamage: SharedConstants.PLAYER_BASE_DAMAGE,
      defaultBulletType: 1,
      buffTimers: {
        speed: 0,
        shield: 0,
        fireAmmo: 0,
        clusterAmmo: 0,
        stealth: 0
      },
      isInvisible: false,
      lastProcessedInputSeq: -1
    };
    
    socket.emit('roomCreated', { roomId, playerId: socket.id, isP1: true });
    console.log(`Room created: ${roomId} by ${socket.id}`);
  });

  // Tham gia ph√≤ng (t·ª± ƒë·ªông khi c√≥ ng∆∞·ªùi th·ª© 2 connect)
  socket.on('joinRoom', (data) => {
    const { roomId } = data;
    console.log(`Player ${socket.id} attempting to join room: ${roomId}`);
    console.log('Available rooms:', Array.from(games.keys()));
    const game = games.get(roomId);
    
    if (!game) {
      console.log(`Room ${roomId} not found!`);
      socket.emit('roomNotFound');
      return;
    }
    
    const playerIds = Object.keys(game.players);
    if (playerIds.length >= 2) {
      socket.emit('roomFull');
      return;
    }
    
    socket.join(roomId);
    const isP1 = false;
    game.players[socket.id] = {
      id: 'p2',
      x: game.map.width - SharedConstants.PLAYER_P2_SPAWN_OFFSET.x,
      y: game.map.height - SharedConstants.PLAYER_P2_SPAWN_OFFSET.y,
      width: SharedConstants.TANK_WIDTH,
      height: SharedConstants.TANK_HEIGHT,
      speed: SharedConstants.TANK_BASE_SPEED,
      health: SharedConstants.PLAYER_MAX_HEALTH,
      maxHealth: SharedConstants.PLAYER_MAX_HEALTH,
      shield: SharedConstants.PLAYER_BASE_SHIELD,
      damage: SharedConstants.PLAYER_BASE_DAMAGE,
      bulletType: 1,
      lastDx: 0,
      lastDy: -1,
      angle: 0,
      keys: { up: false, down: false, left: false, right: false, shoot: false, priority: [] },
      canShoot: true,
      lastShootTime: 0,
      shootCooldown: SharedConstants.SHOOT_COOLDOWN,
      defaultSpeed: SharedConstants.TANK_BASE_SPEED,
      defaultDamage: SharedConstants.PLAYER_BASE_DAMAGE,
      defaultBulletType: 1,
      buffTimers: {
        speed: 0,
        shield: 0,
        fireAmmo: 0,
        clusterAmmo: 0,
        stealth: 0
      },
      isInvisible: false,
      lastProcessedInputSeq: -1
    };
    
    socket.emit('joined', { playerId: socket.id, isP1: false });
    socket.emit('joinedRoom', { playerId: socket.id, isP1: false, playerCount: Object.keys(game.players).length });
    io.to(roomId).emit('playerJoined', { playerCount: Object.keys(game.players).length });
    console.log(`Player joined room: ${roomId}`);
  });

  // B·∫Øt ƒë·∫ßu game (ch·ªâ host m·ªõi ƒë∆∞·ª£c) - T·∫†O MAP M·ªöI ·ªû·ªéY
  socket.on('startGame', (data) => {
    const { roomId } = data;
    const game = games.get(roomId);
    
    if (!game) return;
    const playerIds = Object.keys(game.players);
    if (playerIds.length === 0) return;
    // N·∫øu host ƒë√£ r·ªùi, g√°n host m·ªõi l√† player ƒë·∫ßu ti√™n
    if (!game.players[game.hostId]) {
      game.hostId = playerIds[0];
      io.to(roomId).emit('hostChanged', { hostId: game.hostId });
    }
    if (game.hostId !== socket.id) {
      return; // Kh√¥ng ph·∫£i host hi·ªán t·∫°i
    }
    
    if (Object.keys(game.players).length < 2) {
      return; // Ch∆∞a ƒë·ªß ng∆∞·ªùi
    }

    // === T·∫†O MAP V√Ä TURRETS M·ªöI TR∆Ø·ªöC KHI B·∫ÆT ƒê·∫¶U ===
    const newMap = generateMap();
    game.map = newMap;
    game.turrets = generateTurrets(newMap);

    // Reset players v·ªÅ spawn point m·ªõi (map v·ª´a t·∫°o)
    for (let [pid, player] of Object.entries(game.players)) {
      if (player.id === 'p1') {
        player.x = SharedConstants.PLAYER_P1_SPAWN.x;
        player.y = SharedConstants.PLAYER_P1_SPAWN.y;
      } else {
        player.x = game.map.width - SharedConstants.PLAYER_P2_SPAWN_OFFSET.x;
        player.y = game.map.height - SharedConstants.PLAYER_P2_SPAWN_OFFSET.y;
      }
    }

    game.bullets = [];
    game.items = [];
    game.bulletSeq = 1;
    game.isGameOver = false;
    game.winner = null;
    game.isPlaying = true;
    itemSpawnTimer = 0;

    io.to(roomId).emit('gameStarted');
    io.to(roomId).emit('gameState', game);
    console.log(`Game started in room: ${roomId}`);
  });



  // R·ªùi ph√≤ng
  socket.on('leaveRoom', (data) => {
    const { roomId } = data;
    const game = games.get(roomId);
    if (game) {
      const wasHost = game.hostId === socket.id;
      
      delete game.players[socket.id];
      socket.leave(roomId);
      
      const remaining = Object.keys(game.players);
      if (remaining.length === 0) {
        games.delete(roomId);
        console.log(`Room deleted: ${roomId}`);
      } else {
        // N·∫øu l√† host, kick t·∫•t c·∫£ th√†nh vi√™n c√≤n l·∫°i v·ªÅ lobby
        if (wasHost) {
          io.to(roomId).emit('hostLeft');
          remaining.forEach(socketId => {
            io.sockets.sockets.get(socketId)?.leave(roomId);
          });
          games.delete(roomId);
          console.log(`Host left room ${roomId}, all players kicked out`);
        } else if (game.isPlaying && !game.isGameOver) {
          // N·∫øu game ƒëang ch∆°i, ng∆∞·ªùi c√≤n l·∫°i th·∫Øng
          game.isGameOver = true;
          const remainingPlayer = game.players[remaining[0]];
          game.winner = remainingPlayer.id;
          io.to(roomId).emit('gameState', game);
          console.log(`Player left room during game. Winner: ${game.winner}`);
        }
      }
    }
  });

  // Ensure player input is processed correctly for tank control
  socket.on('playerInput', (data) => {
    const { roomId, input } = data;
    const game = games.get(roomId);
    if (game && game.players[socket.id]) {
      const player = game.players[socket.id];
      const { seq, ...keyState } = input || {};
      player.keys = keyState;
      player.lastProcessedInputSeq = typeof seq === 'number' ? seq : (player.lastProcessedInputSeq ?? -1);
      if (!keyState.shoot) player.canShoot = true;
    }
  });

  socket.on('disconnect', () => {
    for (let [roomId, game] of games) {
      if (game.players[socket.id]) {
        const wasHost = game.hostId === socket.id;
        
        delete game.players[socket.id];
        const remaining = Object.keys(game.players);
        
        if (remaining.length === 0) {
          console.log(`Deleted empty room: ${roomId}`);
          games.delete(roomId);
        } else {
          // N·∫øu l√† host disconnect, kick t·∫•t c·∫£ th√†nh vi√™n v·ªÅ lobby
          if (wasHost) {
            io.to(roomId).emit('hostLeft');
            remaining.forEach(socketId => {
              io.sockets.sockets.get(socketId)?.leave(roomId);
            });
            games.delete(roomId);
            console.log(`Host disconnected from room ${roomId}, all players kicked out`);
          } else if (game.isPlaying && !game.isGameOver) {
            // N·∫øu game ƒëang ch∆°i, ng∆∞·ªùi c√≤n l·∫°i th·∫Øng
            game.isGameOver = true;
            const remainingPlayer = game.players[remaining[0]];
            game.winner = remainingPlayer.id;
            io.to(roomId).emit('gameState', game);
            console.log(`Player disconnected during game. Winner: ${game.winner}`);
          }
        }
        break;
      }
    }
  });
});

// Physics loop on server (run every 16ms ~60fps)
// T√≠nh to√°n v·∫≠t l√Ω ch·∫°y ·ªü 60fps ƒë·ªÉ ƒë·∫£m b·∫£o gameplay ch√≠nh x√°c v√† m∆∞·ª£t m√†
const PHYSICS_INTERVAL = 1000 / SharedConstants.PHYSICS_UPDATE_RATE;
const physicsLoopId = setInterval(() => {
  try {
    for (let [roomId, game] of games) {
      // Ch·ªâ ch·∫°y physics khi game ƒëang playing
      if (!game.isPlaying || game.isGameOver) continue;

      // Update players
      for (let [id, player] of Object.entries(game.players)) {
        let dx = 0, dy = 0;
        
        // === MOVEMENT PRIORITY SYSTEM (∆ØU TI√äN PH√çM M·ªöI NH·∫§T) ===
        // H·ªá th·ªëng n√†y x·ª≠ l√Ω t√¨nh hu·ªëng nh·∫•n nhi·ªÅu ph√≠m c√πng l√∫c
        // ∆Øu ti√™n: Ph√≠m nh·∫•n m·ªõi nh·∫•t + X·ª≠ l√Ω xung ƒë·ªôt (up vs down, left vs right)
        const priority = player.keys.priority || [];
        
        if (priority.length > 0) {
          // L·∫•y ph√≠m g·∫ßn nh·∫•t t·ª´ priority array
          // Duy·ªát t·ª´ cu·ªëi v·ªÅ ƒë·∫ßu (ph√≠m m·ªõi nh·∫•t ƒë·∫øn c≈© nh·∫•t)
          let verticalSet = false;
          let horizontalSet = false;
          
          for (let i = priority.length - 1; i >= 0; i--) {
            const key = priority[i];
            
            // X·ª≠ l√Ω vertical (up/down) - ch·ªâ l·∫•y ph√≠m m·ªõi nh·∫•t
            if (!verticalSet) {
              if (key === 'up') { dy = -1; verticalSet = true; }
              else if (key === 'down') { dy = 1; verticalSet = true; }
            }
            
            // X·ª≠ l√Ω horizontal (left/right) - ch·ªâ l·∫•y ph√≠m m·ªõi nh·∫•t
            if (!horizontalSet) {
              if (key === 'left') { dx = -1; horizontalSet = true; }
              else if (key === 'right') { dx = 1; horizontalSet = true; }
            }
            
            // N·∫øu ƒë√£ c√≥ c·∫£ vertical v√† horizontal th√¨ d·ª´ng
            if (verticalSet && horizontalSet) break;
          }
        } else {
          // Fallback: N·∫øu kh√¥ng c√≥ priority, d√πng logic c≈©
          if (player.keys.up) dy = -1;
          if (player.keys.down) dy = 1;
          if (player.keys.left) dx = -1;
          if (player.keys.right) dx = 1;
        }

        // Update last direction
        if (dx !== 0 || dy !== 0) {
            player.lastDx = dx;
            player.lastDy = dy;
        }

        // Update player position
        player.x += dx * player.speed;
        player.y += dy * player.speed;

        // Boundary check
        player.x = Math.max(0, Math.min(player.x, game.map.width - player.width));
        player.y = Math.max(0, Math.min(player.y, game.map.height - player.height));

        // Wall collision check with reduced hitbox
        const nearbyWalls = getWallsNear(game.map, player);
        for (let wall of nearbyWalls) {
          // Thu nh·ªè hitbox xe tƒÉng ƒë·ªÉ ƒëi qua khe h·∫πp d·ªÖ h∆°n (padding from SharedConstants)
          const padding = SharedConstants.TANK_HITBOX_PADDING;
          const playerHitbox = {
            x: player.x + padding,
            y: player.y + padding,
            width: player.width - padding * 2,
            height: player.height - padding * 2
          };
          if (SharedUtils.isColliding(playerHitbox, wall)) {
            player.x -= dx * player.speed;
            player.y -= dy * player.speed;
            break;
          }
        }

        // Shooting logic (v·ªõi cooldown)
        const now = Date.now();
        if (player.keys.shoot && player.canShoot && (now - player.lastShootTime >= player.shootCooldown)) {
            // B·∫Øn s√∫ng -> M·∫•t t√†ng h√¨nh
            if (player.isInvisible) {
              player.isInvisible = false;
              player.buffTimers.stealth = 0;
            }
            
            // T√≠nh t√¢m xe tƒÉng
            const centerX = player.x + player.width / 2;
            const centerY = player.y + player.height / 2;
            
            // T√≠nh g√≥c quay c·ªßa xe tƒÉng (gi·ªëng client)
            let angle = Math.atan2(player.lastDy, player.lastDx);
            angle += Math.PI / 2; // ƒêi·ªÅu ch·ªânh v√¨ ·∫£nh xe tƒÉng m·∫∑c ƒë·ªãnh h∆∞·ªõng l√™n
            
            // === C·∫§U H√åNH V·ªä TR√ç SPAWN ƒê·∫†N ===
            // barrelLength: Kho·∫£ng c√°ch t·ª´ t√¢m xe tƒÉng ƒë·∫øn ƒë·∫ßu n√≤ng s√∫ng (pixels)
            const barrelLength = SharedConstants.BULLET_BARREL_LENGTH;
            
            // barrelOffset: ƒê·ªô l·ªách ngang (perpendicular) so v·ªõi h∆∞·ªõng xe tƒÉng
            const barrelOffsetX = 0;  // Offset ngang (pixels)
            const barrelOffsetY = 0;  // Offset d·ªçc (pixels)
            
            // T√≠nh v·ªã tr√≠ spawn d·ª±a tr√™n angle v√† offsets
            const spawnX = centerX + Math.cos(angle - Math.PI / 2) * barrelLength + Math.cos(angle) * barrelOffsetX;
            const spawnY = centerY + Math.sin(angle - Math.PI / 2) * barrelLength + Math.sin(angle) * barrelOffsetY;
            // === H·∫æT C·∫§U H√åNH ===
            
            game.bullets.push({
              id: game.bulletSeq++,
                x: spawnX,
                y: spawnY,
                dx: player.lastDx,
                dy: player.lastDy,
                speed: SharedConstants.BULLET_SPEED,
                ownerId: player.id,
                damage: player.damage,
                type: player.bulletType,
                width: SharedConstants.BULLET_WIDTH,
                height: SharedConstants.BULLET_HEIGHT
            });
            player.canShoot = false;
            player.lastShootTime = now;
        }
      }

      // === TURRET AI LOGIC ===
      const now = Date.now();
      game.turrets.forEach(turret => {
        if (turret.health <= 0) return; // Turret ƒë√£ ch·∫øt
        
        // T√¨m ng∆∞·ªùi ch∆°i g·∫ßn nh·∫•t trong t·∫ßm b·∫Øn
        let closestPlayer = null;
        let closestDist = turret.range + 1;
        
        for (let [id, player] of Object.entries(game.players)) {
          if (player.health <= 0) continue;
          
          const dx = player.x + player.width / 2 - (turret.x + turret.width / 2);
          const dy = player.y + player.height / 2 - (turret.y + turret.height / 2);
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < closestDist) {
            closestDist = dist;
            closestPlayer = player;
          }
        }
        
        // N·∫øu c√≥ target v√† ƒë·ªß cooldown -> b·∫Øn
        if (closestPlayer && now - turret.lastShootTime >= turret.shootCooldown) {
          const centerX = turret.x + turret.width / 2;
          const centerY = turret.y + turret.height / 2;
          const targetX = closestPlayer.x + closestPlayer.width / 2;
          const targetY = closestPlayer.y + closestPlayer.height / 2;
          
          const dx = targetX - centerX;
          const dy = targetY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          game.bullets.push({
            id: game.bulletSeq++,
            x: centerX,
            y: centerY,
            dx: dx / dist,
            dy: dy / dist,
            speed: SharedConstants.BULLET_SPEED,
            ownerId: turret.id,
            damage: turret.damage,
            type: 1, // ƒê·∫°n th∆∞·ªùng
            width: SharedConstants.BULLET_WIDTH,
            height: SharedConstants.BULLET_HEIGHT
          });
          
          turret.lastShootTime = now;
        }
      });

      // Update bullets
      game.bullets.forEach(bullet => {
        bullet.x += bullet.dx * bullet.speed;
        bullet.y += bullet.dy * bullet.speed;
        
        // Fragment bullets: gi·∫£m lifespan
        if (bullet.isFragment && bullet.lifespan !== undefined) {
          bullet.lifespan--;
          if (bullet.lifespan <= 0) {
            bullet.markedForDeletion = true;
          }
        }
        
        // Boundary check
        if (bullet.x < 0 || bullet.x > game.map.width || bullet.y < 0 || bullet.y > game.map.height) {
          bullet.markedForDeletion = true;
        }
      });

      // Bullet collisions
      game.bullets.forEach(bullet => {
        // Wall (use nearby chunks)
        const nearWalls = getWallsNear(game.map, bullet);
        for (let wall of nearWalls) {
          if (bullet.type !== 2 && SharedUtils.isColliding(bullet, wall)) {
            // Cluster Ammo: N·ªï ra ƒë·∫°n con khi ch·∫°m t∆∞·ªùng
            if (bullet.type === 5) {
              createClusterFragments(game, bullet);
            }
            bullet.markedForDeletion = true;
            break;
          }
        }
        
        // Players (t·ª´ turrets ho·∫∑c t·ª´ players kh√°c)
        for (let [id, player] of Object.entries(game.players)) {
          if (bullet.ownerId !== player.id && SharedUtils.isColliding(bullet, player)) {
            // Damage c∆° b·∫£n
            player.health -= bullet.damage - player.shield;
            
            // Fire Ammo: G√¢y burn effect
            if (bullet.type === 4) {
              player.burnEffect = {
                damage: SharedConstants.BUFF_VALUES.FIRE_DOT_DAMAGE,
                duration: SharedConstants.BUFF_VALUES.FIRE_DOT_DURATION
              };
            }
            
            // Cluster Ammo: N·ªï ra ƒë·∫°n con
            if (bullet.type === 5) {
              createClusterFragments(game, bullet);
            }
            
            bullet.markedForDeletion = true;
          }
        }
        
        // Turrets (players c√≥ th·ªÉ b·∫Øn turrets)
        if (!bullet.ownerId.startsWith('turret_')) {
          for (let turret of game.turrets) {
            if (turret.health > 0 && SharedUtils.isColliding(bullet, turret)) {
              turret.health -= bullet.damage;
              
              // Cluster Ammo: N·ªï khi tr√∫ng turret
              if (bullet.type === 5) {
                createClusterFragments(game, bullet);
              }
              
              bullet.markedForDeletion = true;
              break;
            }
          }
        }
      });

      // Item pickup collision
      for (let [id, player] of Object.entries(game.players)) {
        for (let i = game.items.length - 1; i >= 0; i--) {
          const item = game.items[i];
          const itemRect = { x: item.x, y: item.y, width: SharedConstants.ITEM_SIZE, height: SharedConstants.ITEM_SIZE };
          if (SharedUtils.isColliding(player, itemRect)) {
            // Apply item effect based on type (6 types m·ªõi)
            switch(item.type) {
              case 1: // Health
                player.health = Math.min(player.maxHealth, player.health + SharedConstants.BUFF_VALUES.HEALTH_RESTORE);
                break;
              case 2: // Speed boost (10s)
                player.buffTimers.speed = Math.max(player.buffTimers.speed, SharedConstants.BUFF_DURATION.SPEED);
                player.speed = player.defaultSpeed + SharedConstants.BUFF_VALUES.SPEED_BOOST;
                break;
              case 3: // Shield (15s)
                player.shield = SharedConstants.BUFF_VALUES.SHIELD_VALUE;
                player.buffTimers.shield = SharedConstants.BUFF_DURATION.SHIELD;
                break;
              case 4: // Fire Ammo (12s)
                player.bulletType = 4;
                player.buffTimers.fireAmmo = SharedConstants.BUFF_DURATION.FIRE_AMMO;
                player.buffTimers.clusterAmmo = 0; // Cancel cluster
                break;
              case 5: // Cluster Ammo (12s)
                player.bulletType = 5;
                player.buffTimers.clusterAmmo = SharedConstants.BUFF_DURATION.CLUSTER_AMMO;
                player.buffTimers.fireAmmo = 0; // Cancel fire
                break;
              case 6: // Stealth (10s)
                player.isInvisible = true;
                player.buffTimers.stealth = SharedConstants.BUFF_DURATION.STEALTH;
                break;
            }
            // Remove item after pickup
            game.items.splice(i, 1);
          }
        }
      }

      // Update buff timers and reset stats when expired
      for (let [id, player] of Object.entries(game.players)) {
        // Speed buff
        if (player.buffTimers.speed > 0) {
          player.speed = player.defaultSpeed + SharedConstants.BUFF_VALUES.SPEED_BOOST;
          player.buffTimers.speed--;
          if (player.buffTimers.speed === 0) {
            player.speed = player.defaultSpeed;
          }
        }
        // Shield buff
        if (player.buffTimers.shield > 0) {
          player.buffTimers.shield--;
          if (player.buffTimers.shield === 0) {
            player.shield = 0;
          }
        }
        // Fire Ammo buff
        if (player.buffTimers.fireAmmo > 0) {
          player.buffTimers.fireAmmo--;
          if (player.buffTimers.fireAmmo === 0) {
            player.bulletType = player.defaultBulletType;
          }
        }
        // Cluster Ammo buff
        if (player.buffTimers.clusterAmmo > 0) {
          player.buffTimers.clusterAmmo--;
          if (player.buffTimers.clusterAmmo === 0) {
            player.bulletType = player.defaultBulletType;
          }
        }
        // Stealth buff
        if (player.buffTimers.stealth > 0) {
          player.buffTimers.stealth--;
          if (player.buffTimers.stealth === 0) {
            player.isInvisible = false;
          }
        }
        
        // Burn effect (Fire DOT)
        if (player.burnEffect) {
          player.health -= player.burnEffect.damage;
          player.burnEffect.duration--;
          if (player.burnEffect.duration <= 0) {
            delete player.burnEffect;
          }
        }
      }

      game.bullets = game.bullets.filter(b => {
        if (b.markedForDeletion) return false;
        if (b.x < -50 || b.x > game.map.width + 50 || b.y < -50 || b.y > game.map.height + 50) return false;
        return true;
      });

      // Limit total bullets per room
      if (game.bullets.length > SharedConstants.MAX_BULLETS_PER_ROOM) {
        game.bullets = game.bullets.slice(-SharedConstants.MAX_BULLETS_PER_ROOM);
      }

      // Check win/lose
      const players = Object.values(game.players);
      if (players.length === 2) {
        if (players[0].health <= 0) {
          game.isGameOver = true;
          game.winner = players[1].id;
        } else if (players[1].health <= 0) {
          game.isGameOver = true;
          game.winner = players[0].id;
        }
      }

      // Spawn items
      spawnItems(game);
    }
  } catch (e) {
    console.error('Physics loop error:', e);
  }
}, PHYSICS_INTERVAL);

// Network loop - Send updates at 30fps (33ms) ƒë·ªÉ gi·∫£m t·∫£i bƒÉng th√¥ng
// G·ª≠i ·ªü t·∫ßn su·∫•t th·∫•p h∆°n physics (30fps thay v√¨ 60fps) v·∫´n ƒë·ªß m∆∞·ª£t cho m·∫Øt th∆∞·ªùng
// v√† gi·∫£m ƒë√°ng k·ªÉ network traffic, tr√°nh lag qua internet
const NETWORK_INTERVAL = 1000 / SharedConstants.NETWORK_UPDATE_RATE;
const networkLoopId = setInterval(() => {
  try {
    for (let [roomId, game] of games) {
      // Ch·ªâ g·ª≠i update khi game ƒëang playing
      if (!game.isPlaying) continue;
      
      // Broadcast per-player with nearby bullets/items only
      for (let [sockId, pl] of Object.entries(game.players)) {
        const view = buildViewStateFor(game, pl);
        io.to(sockId).emit('updateState', view);
      }
    }
  } catch (e) {
    console.error('Network loop error:', e);
  }
}, NETWORK_INTERVAL);

// Collision utility (now using SharedUtils)
function isColliding(rect1, rect2) {
  return SharedUtils.isColliding(rect1, rect2);
}

// Build a trimmed state for a specific player (Minecraft-like: only nearby)
function buildViewStateFor(game, player) {
  const padX = SharedConstants.VIEW_PADDING_X; // radius X to include entities
  const padY = SharedConstants.VIEW_PADDING_Y; // radius Y to include entities
  const rect = {
    x: Math.max(0, player.x - padX),
    y: Math.max(0, player.y - padY),
    width: padX * 2,
    height: padY * 2
  };

  const bullets = game.bullets.filter(b => (
    b.x >= rect.x && b.x <= rect.x + rect.width &&
    b.y >= rect.y && b.y <= rect.y + rect.height
  ));

  const items = game.items.filter(i => (
    i.x + 30 >= rect.x && i.x <= rect.x + rect.width &&
    i.y + 30 >= rect.y && i.y <= rect.y + rect.height
  ));
  
  // Turrets trong viewport (lu√¥n g·ª≠i to√†n b·ªô ƒë·ªÉ client v·∫Ω mini-map)
  const turrets = game.turrets;

  return {
    players: game.players,
    bullets,
    items,
    turrets,
    map: { width: game.map.width, height: game.map.height },
    isGameOver: game.isGameOver,
    winner: game.winner
  };
}

server.listen(PORT, () => console.log(`Server running on port ${PORT}`));

====================
FILE: SharedConstants.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\shared\SharedConstants.js
====================
/**
 * SharedConstants.js
 * 
 * File n√†y ch·ª©a t·∫•t c·∫£ c√°c h·∫±ng s·ªë d√πng chung cho c·∫£ Client v√† Server
 * ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô gi·ªØa 2 b√™n v√† d·ªÖ d√†ng ƒëi·ªÅu ch·ªânh gameplay.
 * 
 * S·ª≠ d·ª•ng:
 * - Client: <script src="shared/SharedConstants.js"></script>
 * - Server: const SharedConstants = require('./shared/SharedConstants.js');
 */

// ===========================
// MAP CONSTANTS
// ===========================
const MAP_WIDTH = 2400;   // TƒÉng g·∫•p ƒë√¥i (2400x2400)
const MAP_HEIGHT = 2400;
const TILE_SIZE = 50;  // K√≠ch th∆∞·ªõc √¥ map (t∆∞∆°ng ·ª©ng v·ªõi ·∫£nh wall.png)
const CHUNK_SIZE = 400; // TƒÉng chunk size ƒë·ªÉ t·ªëi ∆∞u v·ªõi map l·ªõn

// ===========================
// TANK CONSTANTS
// ===========================
const TANK_WIDTH = 46;
const TANK_HEIGHT = 46;
const TANK_BASE_SPEED = 2.5;
const TANK_HITBOX_PADDING = 8; // Thu nh·ªè hitbox ƒë·ªÉ ƒëi qua khe h·∫πp d·ªÖ h∆°n

// ===========================
// BULLET CONSTANTS
// ===========================
const BULLET_WIDTH = 10;
const BULLET_HEIGHT = 10;
const BULLET_SPEED = 12.5; // 5x t·ªëc ƒë·ªô xe tƒÉng
const BULLET_DAMAGE_BASE = 20;  // TƒÉng t·ª´ 10 -> 20
const BULLET_BARREL_LENGTH = 35; // Kho·∫£ng c√°ch spawn ƒë·∫°n t·ª´ t√¢m xe
const SHOOT_COOLDOWN = 200; // ms gi·ªØa m·ªói l·∫ßn b·∫Øn

// ===========================
// PLAYER CONSTANTS
// ===========================
const PLAYER_MAX_HEALTH = 200;  // TƒÉng t·ª´ 100 -> 200
const PLAYER_BASE_DAMAGE = 20;  // TƒÉng t·ª´ 10 -> 20
const PLAYER_BASE_SHIELD = 0;

// V·ªã tr√≠ spawn m·∫∑c ƒë·ªãnh
const PLAYER_P1_SPAWN = { x: 175, y: 175 };
const PLAYER_P2_SPAWN_OFFSET = { x: 225, y: 225 }; // T√≠nh t·ª´ g√≥c d∆∞·ªõi-ph·∫£i map

// ===========================
// ITEM CONSTANTS
// ===========================
const ITEM_SIZE = 30;
const ITEM_SPAWN_INTERVAL = 120; // frames (2 seconds t·∫°i 60fps)
const ITEM_MAX_PER_ROOM = 30; // Gi·ªõi h·∫°n s·ªë item spawn

// S·ªë l∆∞·ª£ng target cho m·ªói lo·∫°i item (ƒê√£ c·∫≠p nh·∫≠t: 6 types m·ªõi)
const ITEM_TARGETS = {
  HEALTH: 4,        // type 1 - Gi·ªØ l·∫°i
  SPEED: 4,         // type 2 - Gi·ªØ l·∫°i
  SHIELD: 4,        // type 3 - Gi·ªØ l·∫°i
  FIRE_AMMO: 3,     // type 4 - M·ªõi: ƒê·∫°n l·ª≠a
  CLUSTER_AMMO: 3,  // type 5 - M·ªõi: ƒê·∫°n ch√πm
  STEALTH: 2        // type 6 - M·ªõi: T√†ng h√¨nh
};

// Th·ªùi gian buff (frames t·∫°i 60fps)
const BUFF_DURATION = {
  SPEED: 600,        // 10 seconds
  SHIELD: 900,       // 15 seconds
  FIRE_AMMO: 720,    // 12 seconds
  CLUSTER_AMMO: 720, // 12 seconds
  STEALTH: 600       // 10 seconds
};

// Gi√° tr·ªã buff
const BUFF_VALUES = {
  HEALTH_RESTORE: 30,
  SPEED_BOOST: 1.5,       // Th√™m v√†o base speed
  SHIELD_VALUE: 10,       // Gi·∫£m damage nh·∫≠n v√†o
  FIRE_DOT_DAMAGE: 3,     // Damage per tick cho Fire DOT
  FIRE_DOT_DURATION: 180, // 3 seconds (t·∫°i 60fps)
  CLUSTER_FRAG_COUNT: 6,  // S·ªë ƒë·∫°n con khi n·ªï
  CLUSTER_FRAG_DAMAGE: 10 // Damage c·ªßa ƒë·∫°n con
};

// ===========================
// MAP GENERATION CONSTANTS
// ===========================
const MAP_OBSTACLE_DENSITY = 0.10; // 10% chance ƒë·ªÉ spawn obstacle
const MAP_SAFE_ZONE_SIZE = 7; // 7x7 tiles safe zone ·ªü 2 g√≥c

// ===========================
// NETWORK CONSTANTS
// ===========================
const PHYSICS_UPDATE_RATE = 60; // Hz (16ms per frame)
const NETWORK_UPDATE_RATE = 30; // Hz (33ms per frame)
const INPUT_THROTTLE_RATE = 30; // Hz (33ms) - gi·ªõi h·∫°n g·ª≠i input

// Interpolation settings
const LERP_FACTOR = 0.5; // ƒê·ªô m∆∞·ª£t khi lerp v·ªã tr√≠ (0-1)
const SNAP_THRESHOLD = 150; // Tang t? 50 cho map l?n 2400x2400 // pixels - N·∫øu l·ªách > 50px th√¨ snap thay v√¨ lerp

// View distance (Minecraft-like optimization)
const VIEW_PADDING_X = 800;
const VIEW_PADDING_Y = 600;

// ===========================
// ROOM CONSTANTS
// ===========================
const MAX_BULLETS_PER_ROOM = 30;
const MAX_PLAYERS_PER_ROOM = 2;

// ===========================
// TURRET CONSTANTS (M·ªöI)
// ===========================
const TURRET_MAX_HEALTH = 300;
const TURRET_DAMAGE = 15;
const TURRET_RANGE = 400;       // T·∫ßm b·∫Øn (pixels)
const TURRET_SHOOT_COOLDOWN = 1200; // 20 frames = ~2 gi√¢y (ch·∫≠m l·∫°i)
const TURRET_SIZE = 40;         // K√≠ch th∆∞·ªõc v·∫Ω turret
const TURRET_COUNT = 8;         // S·ªë l∆∞·ª£ng turret tr√™n map

// ===========================
// Export cho c·∫£ Node.js v√† Browser
// ===========================
const SharedConstants = {
  // Map
  MAP_WIDTH,
  MAP_HEIGHT,
  TILE_SIZE,
  CHUNK_SIZE,
  
  // Tank
  TANK_WIDTH,
  TANK_HEIGHT,
  TANK_BASE_SPEED,
  TANK_HITBOX_PADDING,
  
  // Bullet
  BULLET_WIDTH,
  BULLET_HEIGHT,
  BULLET_SPEED,
  BULLET_DAMAGE_BASE,
  BULLET_BARREL_LENGTH,
  SHOOT_COOLDOWN,
  
  // Player
  PLAYER_MAX_HEALTH,
  PLAYER_BASE_DAMAGE,
  PLAYER_BASE_SHIELD,
  PLAYER_P1_SPAWN,
  PLAYER_P2_SPAWN_OFFSET,
  
  // Items
  ITEM_SIZE,
  ITEM_SPAWN_INTERVAL,
  ITEM_MAX_PER_ROOM,
  ITEM_TARGETS,
  BUFF_DURATION,
  BUFF_VALUES,
  
  // Map Generation
  MAP_OBSTACLE_DENSITY,
  MAP_SAFE_ZONE_SIZE,
  
  // Network
  PHYSICS_UPDATE_RATE,
  NETWORK_UPDATE_RATE,
  INPUT_THROTTLE_RATE,
  LERP_FACTOR,
  SNAP_THRESHOLD,
  VIEW_PADDING_X,
  VIEW_PADDING_Y,
  
  // Room
  MAX_BULLETS_PER_ROOM,
  MAX_PLAYERS_PER_ROOM,
  
  // Turret (M·ªõi)
  TURRET_MAX_HEALTH,
  TURRET_DAMAGE,
  TURRET_RANGE,
  TURRET_SHOOT_COOLDOWN,
  TURRET_SIZE,
  TURRET_COUNT
};

// Export cho Node.js (server)
if (typeof module !== 'undefined' && module.exports) {
  module.exports = SharedConstants;
}

// Export cho Browser (client)
if (typeof window !== 'undefined') {
  window.SharedConstants = SharedConstants;
}

====================
FILE: SharedUtils.js
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\shared\SharedUtils.js
====================
/**
 * SharedUtils.js
 * 
 * File n√†y ch·ª©a c√°c h√†m utility d√πng chung cho c·∫£ Client v√† Server
 * ƒë·ªÉ ƒë·∫£m b·∫£o logic nh·∫•t qu√°n gi·ªØa 2 b√™n.
 * 
 * Quan tr·ªçng: Client-side Prediction
 * ===================================
 * Client c·∫ßn d√πng c√πng h√†m isColliding ƒë·ªÉ ki·ªÉm tra va ch·∫°m v·ªõi t∆∞·ªùng
 * TR∆Ø·ªöC KHI g·ª≠i input l√™n server. ƒêi·ªÅu n√†y tr√°nh xe ƒëi xuy√™n t∆∞·ªùng r·ªìi
 * b·ªã server gi·∫≠t l√πi l·∫°i (rubber banding).
 * 
 * S·ª≠ d·ª•ng:
 * - Client: <script src="shared/SharedUtils.js"></script>
 * - Server: const SharedUtils = require('./shared/SharedUtils.js');
 */

/**
 * Ki·ªÉm tra va ch·∫°m gi·ªØa 2 h√¨nh ch·ªØ nh·∫≠t (AABB - Axis-Aligned Bounding Box)
 * @param {Object} rect1 - {x, y, width, height}
 * @param {Object} rect2 - {x, y, width, height}
 * @returns {boolean} - true n·∫øu 2 h√¨nh ch·ªØ nh·∫≠t va ch·∫°m
 */
function isColliding(rect1, rect2) {
  return (
    rect1.x < rect2.x + rect2.width &&
    rect1.x + rect1.width > rect2.x &&
    rect1.y < rect2.y + rect2.height &&
    rect1.y + rect1.height > rect2.y
  );
}

/**
 * Ki·ªÉm tra va ch·∫°m v·ªõi m·∫£ng c√°c t∆∞·ªùng
 * @param {Object} rect - {x, y, width, height}
 * @param {Array} walls - M·∫£ng c√°c wall object
 * @returns {boolean} - true n·∫øu rect va ch·∫°m v·ªõi b·∫•t k·ª≥ wall n√†o
 */
function isCollidingWithWalls(rect, walls) {
  for (let wall of walls) {
    if (isColliding(rect, wall)) {
      return true;
    }
  }
  return false;
}

/**
 * T√≠nh kho·∫£ng c√°ch gi·ªØa 2 ƒëi·ªÉm
 * @param {number} x1 
 * @param {number} y1 
 * @param {number} x2 
 * @param {number} y2 
 * @returns {number} - Kho·∫£ng c√°ch Euclidean
 */
function distance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Linear interpolation (Lerp)
 * @param {number} start - Gi√° tr·ªã b·∫Øt ƒë·∫ßu
 * @param {number} end - Gi√° tr·ªã k·∫øt th√∫c
 * @param {number} factor - H·ªá s·ªë lerp (0-1)
 * @returns {number} - Gi√° tr·ªã ƒë√£ lerp
 */
function lerp(start, end, factor) {
  return start + (end - start) * factor;
}

/**
 * Clamp m·ªôt gi√° tr·ªã trong kho·∫£ng [min, max]
 * @param {number} value 
 * @param {number} min 
 * @param {number} max 
 * @returns {number}
 */
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

/**
 * Ki·ªÉm tra xem m·ªôt ƒëi·ªÉm c√≥ n·∫±m trong h√¨nh ch·ªØ nh·∫≠t kh√¥ng
 * @param {number} x 
 * @param {number} y 
 * @param {Object} rect - {x, y, width, height}
 * @returns {boolean}
 */
function pointInRect(x, y, rect) {
  return (
    x >= rect.x &&
    x <= rect.x + rect.width &&
    y >= rect.y &&
    y <= rect.y + rect.height
  );
}

/**
 * T√≠nh g√≥c (radian) t·ª´ ƒëi·ªÉm (x1, y1) ƒë·∫øn ƒëi·ªÉm (x2, y2)
 * @param {number} x1 
 * @param {number} y1 
 * @param {number} x2 
 * @param {number} y2 
 * @returns {number} - G√≥c t√≠nh b·∫±ng radian
 */
function angleToPoint(x1, y1, x2, y2) {
  return Math.atan2(y2 - y1, x2 - x1);
}

// ===========================
// Export cho c·∫£ Node.js v√† Browser
// ===========================
const SharedUtils = {
  isColliding,
  isCollidingWithWalls,
  distance,
  lerp,
  clamp,
  pointInRect,
  angleToPoint
};

// Export cho Node.js (server)
if (typeof module !== 'undefined' && module.exports) {
  module.exports = SharedUtils;
}

// Export cho Browser (client)
if (typeof window !== 'undefined') {
  window.SharedUtils = SharedUtils;
}

====================
FILE: index.html
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\index.html
====================
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Tank Battle Online</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/tank1.png" type="image/png">
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    
    <!-- Shared Constants and Utils -->
    <script src="shared/SharedConstants.js"></script>
    <script src="shared/SharedUtils.js"></script>
</head>
<body>

    <canvas id="canvas" width="1200" height="600"></canvas>
    
    <!-- Mini-map Canvas (g√≥c ph·∫£i tr√™n) -->
    <canvas id="minimap" width="200" height="200"></canvas>

    <!-- Loading Overlay -->
    <div id="loading-layer">
        <div class="loading-box">
            <h2>ƒêANG T·∫¢I T√ÄI NGUY√äN...</h2>
            <div class="progress">
                <div class="progress-bar" id="loading-progress" style="width: 0%"></div>
            </div>
            <div id="loading-text">ƒêang t·∫£i h√¨nh ·∫£nh (0%)</div>
        </div>
    </div>

    <!-- Lobby Menu -->
    <div id="lobby-layer" style="display: none;">
        <div class="lobby-box">
            <h1>TANK BATTLE ONLINE</h1>
            <div class="lobby-content">
                <button id="createRoomBtn" class="primary-btn">T·∫†O PH√íNG M·ªöI</button>
                <div class="divider">HO·∫∂C</div>
                <label for="roomIdInput" style="margin-bottom: 8px;">Nh·∫≠p Room ID:</label>
                <input type="text" id="roomIdInput" placeholder="Nh·∫≠p m√£ ph√≤ng..." maxlength="10">
                <button id="joinRoomBtn" class="secondary-btn">THAM GIA PH√íNG</button>
                <button id="settingsBtn">C√ÄI ƒê·∫∂T</button>
            </div>
        </div>
    </div>

    <!-- Waiting Room (ch·ªù ng∆∞·ªùi ch∆°i th·ª© 2) -->
    <div id="waiting-layer" style="display: none;">
        <div class="waiting-box">
            <h1>PH√íNG CH∆†I</h1>
            <div class="waiting-content">
                <p class="instruction-text">G·ª≠i m√£ ph√≤ng cho b·∫°n b√® ƒë·ªÉ tham gia:</p>
                <div class="room-id-container">
                    <p id="room-id-display">Room ID: <span id="room-id-text"></span></p>
                    <button id="copyRoomIdBtn" class="copy-btn">üìã COPY</button>
                </div>
                <p id="player-count">Ng∆∞·ªùi ch∆°i: <span id="player-count-text">1/2</span></p>
                <div id="player-list">
                    <div class="player-item">P1: ƒêang ch·ªù...</div>
                    <div class="player-item">P2: Ch∆∞a tham gia</div>
                </div>
                <p class="waiting-msg">ƒêang ch·ªù ng∆∞·ªùi ch∆°i th·ª© hai...</p>
                <button id="startGameBtn" style="display: none;">B·∫ÆT ƒê·∫¶U TR·∫¨N ƒê·∫§U</button>
                <button id="leaveRoomBtn">R·ªúI PH√íNG</button>
            </div>
        </div>
    </div>

    <!-- Settings Menu -->
    <div id="settings-layer" style="display: none;">
        <div class="settings-box">
            <h1>C√ÄI ƒê·∫∂T PH√çM</h1>
            <div class="settings-content">
                <div class="control-group">
                    <label>Di chuy·ªÉn l√™n: <input type="text" id="control-up" maxlength="1" value="w"></label>
                    <label>Di chuy·ªÉn xu·ªëng: <input type="text" id="control-down" maxlength="1" value="s"></label>
                    <label>Di chuy·ªÉn tr√°i: <input type="text" id="control-left" maxlength="1" value="a"></label>
                    <label>Di chuy·ªÉn ph·∫£i: <input type="text" id="control-right" maxlength="1" value="d"></label>
                    <label>B·∫Øn: <input type="text" id="control-shoot" maxlength="1" value=" "></label>
                </div>
            </div>
            <div class="settings-btn-group">
                <button id="saveSettingsBtn">L∆ØU</button>
                <button id="backToLobbyBtn">QUAY L·∫†I</button>
            </div>
        </div>
    </div>

    <!-- M√†n h√¨nh game over -->
    <div id="game-over-layer" style="display: none;">
        <div class="game-over-box">
            <h2 id="winner-text">PLAYER 1 CHI·∫æN TH·∫ÆNG!</h2>
            <div class="btn-group">
                <button id="homeBtn">M√ÄN H√åNH CH√çNH</button>
            </div>
        </div>
    </div>

    <script src="js/Utils.js"></script>
    <script src="js/AudioManager.js"></script>
    <script src="js/Bullet.js"></script>
    <script src="js/Tank.js"></script>
    <script src="js/Items.js"></script>
    <script src="js/Particle.js"></script>
    <script src="js/Map.js"></script>
    <script src="js/Config.js"></script>
    <script src="js/ImageLoader.js"></script>
    <script src="js/Renderer.js"></script>
    <script src="js/Game.js"></script>
    <script src="js/UIManager.js"></script>
    <script src="js/main.js"></script>

</body>
</html>

====================
FILE: style.css
PATH: C:\Users\ADMIN\Documents\vscode\TankBattle_V3\style.css
====================
/* style.css - ƒê√£ t·ªëi ∆∞u cho Game Online */

:root {
    --main-bg-color: #1a1a1a;
    --accent-color: #ffc107;
    --text-color: #e0e0e0;
}

body {
    background-color: var(--main-bg-color);
    background-image: 
        linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.7)),
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,255,255,0.05) 2px, rgba(255,255,255,0.05) 4px),
        repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(255,255,255,0.05) 2px, rgba(255,255,255,0.05) 4px);
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: 'Chakra Petch', sans-serif;
    color: var(--text-color);
    overflow: hidden;
}

/* Canvas cƒÉn gi·ªØa m√†n h√¨nh */
canvas {
    background-color: #000;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0,0,0,0.8);
    border: 2px solid #333;
    display: block; /* ƒê·∫£m b·∫£o kh√¥ng b·ªã d√≠nh inline spacing */
}

/* Mini-map canvas (g√≥c ph·∫£i tr√™n) */
#minimap {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    border: 2px solid #ffc107;
    border-radius: 5px;
    z-index: 100;
    box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
}

/* --- LOBBY MENU --- */
#lobby-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 300;
    display: flex;
    justify-content: center;
    align-items: center;
}

.lobby-box {
    background-color: #2c3e50;
    border: 4px solid #f1c40f;
    padding: 50px;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
    min-width: 350px;
}

.lobby-box h1 {
    color: #fff;
    font-family: 'Chakra Petch', sans-serif;
    font-size: 48px;
    margin-bottom: 40px;
    text-transform: uppercase;
    text-shadow: 0 0 10px #f1c40f;
}

.lobby-content {
    margin-bottom: 30px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.lobby-content label {
    color: #e0e0e0;
    font-size: 18px;
    margin-right: 10px;
}

.lobby-content input {
    padding: 10px;
    font-size: 16px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 10px;
}

.lobby-content input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 5px rgba(52, 152, 219, 0.5);
}

.divider {
    text-align: center;
    color: #95a5a6;
    font-size: 14px;
    margin: 15px 0;
    position: relative;
}

.divider::before,
.divider::after {
    content: '';
    position: absolute;
    top: 50%;
    width: 40%;
    height: 1px;
    background-color: #7f8c8d;
}

.divider::before {
    left: 0;
}

.divider::after {
    right: 0;
}

.primary-btn {
    background-color: #27ae60 !important;
    color: white !important;
    border: 2px solid #2ecc71 !important;
    font-size: 20px !important;
    padding: 15px 30px !important;
}

.primary-btn:hover {
    background-color: #2ecc71 !important;
    transform: scale(1.05) !important;
}

.secondary-btn {
    background-color: #3498db !important;
    color: white !important;
    border: 2px solid #5dade2 !important;
    font-size: 18px !important;
    padding: 12px 25px !important;
}

.secondary-btn:hover {
    background-color: #5dade2 !important;
    transform: scale(1.05) !important;
}

/* --- WAITING ROOM --- */
#waiting-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 300;
    display: flex;
    justify-content: center;
    align-items: center;
}

.waiting-box {
    background-color: #2c3e50;
    border: 4px solid #3498db;
    padding: 40px;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 0 20px rgba(52, 152, 219, 0.5);
    min-width: 400px;
}

.waiting-box h1 {
    color: #fff;
    font-family: 'Chakra Petch', sans-serif;
    font-size: 40px;
    margin-bottom: 30px;
    text-transform: uppercase;
    text-shadow: 0 0 10px #3498db;
}

.waiting-content {
    color: #e0e0e0;
    font-size: 16px;
}

.waiting-content p {
    margin: 15px 0;
    font-size: 18px;
}

.instruction-text {
    color: #95a5a6;
    font-size: 14px;
    font-style: italic;
    margin-bottom: 10px;
}

.room-id-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin-bottom: 10px;
}

#room-id-display {
    margin: 0 !important;
}

#room-id-text {
    color: #f1c40f;
    font-weight: bold;
    font-size: 22px;
    font-family: 'Courier New', monospace;
    user-select: all;
    cursor: text;
    padding: 5px 10px;
    background-color: rgba(0,0,0,0.3);
    border-radius: 4px;
    white-space: nowrap;
    overflow: visible;
    display: inline-block;
}

.copy-btn {
    background-color: #3498db;
    color: white;
    border: 2px solid #5dade2;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: 0.2s;
}

.copy-btn:hover {
    background-color: #5dade2;
    transform: scale(1.05);
}

.copy-btn:active {
    transform: scale(0.95);
}

#player-count-text {
    color: #2ecc71;
    font-weight: bold;
    font-size: 20px;
}

#player-list {
    margin: 20px 0;
    text-align: left;
    background-color: rgba(0,0,0,0.3);
    padding: 15px;
    border-radius: 8px;
}

.player-item {
    padding: 8px;
    margin: 5px 0;
    background-color: rgba(255,255,255,0.05);
    border-radius: 4px;
}

.waiting-msg {
    color: #f39c12;
    font-style: italic;
    margin: 20px 0;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.lobby-content button {
    padding: 15px 30px;
    font-family: 'Chakra Petch', sans-serif;
    font-size: 20px;
    font-weight: bold;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: 0.3s;
    margin: 10px;
}

#joinBtn {
    background-color: #27ae60;
    color: white;
}

#joinBtn:hover {
    background-color: #2ecc71;
    transform: scale(1.05);
}

#settingsBtn {
    background-color: #f39c12;
    color: white;
}

#settingsBtn:hover {
    background-color: #e67e22;
    transform: scale(1.05);
}

/* Loading Overlay */
#loading-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 400;
    display: flex;
    justify-content: center;
    align-items: center;
}

.loading-box {
    background-color: #2c3e50;
    border: 4px solid #f1c40f;
    padding: 40px;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
    min-width: 360px;
}

.loading-box h2 {
    color: #fff;
    font-family: 'Chakra Petch', sans-serif;
    font-size: 28px;
    margin-bottom: 20px;
    text-transform: uppercase;
}

.progress {
    width: 100%;
    height: 16px;
    background: #1a1a1a;
    border: 2px solid #f1c40f;
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 12px;
}

.progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #f1c40f, #ffd54f);
    transition: width 0.2s ease;
}

#loading-text {
    color: #e0e0e0;
    font-size: 16px;
}

/* --- GAME OVER LAYER --- */
#game-over-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.85); /* N·ªÅn ƒëen m·ªù */
    z-index: 200; /* N·∫±m ƒë√® l√™n t·∫•t c·∫£ */
    
    display: flex;
    justify-content: center;
    align-items: center;
}

/* C√°i b·∫£ng th√¥ng b√°o */
.game-over-box {
    background-color: #2c3e50;
    border: 4px solid #f1c40f; /* Vi·ªÅn v√†ng */
    padding: 40px;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
    min-width: 300px;
}

/* Ch·ªØ ng∆∞·ªùi th·∫Øng */
#winner-text {
    color: #fff;
    font-family: 'Chakra Petch', sans-serif;
    font-size: 32px;
    margin-bottom: 30px;
    text-transform: uppercase;
}

/* Nh√≥m n√∫t b·∫•m */
.btn-group {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* Ki·ªÉu chung cho 2 n√∫t */
.game-over-box button {
    padding: 12px 20px;
    font-family: 'Chakra Petch', sans-serif;
    font-size: 18px;
    font-weight: bold;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: 0.2s;
}

/* N√∫t Ch∆°i l·∫°i (M√†u xanh) */
#restartBtn {
    background-color: #27ae60;
    color: white;
}
#restartBtn:hover { background-color: #2ecc71; }

/* N√∫t V·ªÅ m√†n h√¨nh ch√≠nh (M√†u ƒë·ªè) */
#homeBtn {
    background-color: #c0392b;
    color: white;
}
#homeBtn:hover { background-color: #e74c3c; }
/* --- M√ÄN H√åNH CH√çNH (Main Menu) --- */

/* --- SETTINGS MENU --- */
#settings-layer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 400;
    display: flex;
    justify-content: center;
    align-items: center;
}

.settings-box {
    background-color: #2c3e50;
    border: 4px solid #f1c40f;
    padding: 40px;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 0 20px rgba(241, 196, 15, 0.5);
    min-width: 400px;
}

.settings-box h1 {
    color: #fff;
    font-family: 'Chakra Petch', sans-serif;
    font-size: 36px;
    margin-bottom: 30px;
    text-transform: uppercase;
    text-shadow: 0 0 10px #f1c40f;
}

.settings-content {
    display: flex;
    justify-content: center;
    margin-bottom: 30px;
}

.control-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.control-group label {
    color: #e0e0e0;
    font-size: 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
}

.control-group input {
    width: 80px;
    padding: 8px;
    text-align: center;
    font-size: 16px;
    border: 2px solid #f1c40f;
    border-radius: 4px;
    background-color: #1a1a1a;
    color: #fff;
    font-family: 'Chakra Petch', sans-serif;
}

.settings-btn-group {
    display: flex;
    gap: 20px;
    justify-content: center;
}

.settings-btn-group button {
    padding: 12px 25px;
    font-family: 'Chakra Petch', sans-serif;
    font-size: 18px;
    font-weight: bold;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: 0.3s;
    text-transform: uppercase;
}

#saveSettingsBtn {
    background-color: #27ae60;
    color: white;
}
#saveSettingsBtn:hover { background-color: #2ecc71; transform: scale(1.05); }

#backToLobbyBtn {
    background-color: #c0392b;
    color: white;
}
#backToLobbyBtn:hover { background-color: #e74c3c; transform: scale(1.05); }
